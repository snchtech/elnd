"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app-pages-internals",{

/***/ "(app-pages-browser)/./node_modules/next/dist/server/request/params.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/server/request/params.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createParamsFromClient: function() {\n        return createParamsFromClient;\n    },\n    createPrerenderParamsForClientSegment: function() {\n        return createPrerenderParamsForClientSegment;\n    },\n    createServerParamsForMetadata: function() {\n        return createServerParamsForMetadata;\n    },\n    createServerParamsForRoute: function() {\n        return createServerParamsForRoute;\n    },\n    createServerParamsForServerSegment: function() {\n        return createServerParamsForServerSegment;\n    }\n});\nconst _reflect = __webpack_require__(/*! ../web/spec-extension/adapters/reflect */ \"(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\");\nconst _dynamicrendering = __webpack_require__(/*! ../app-render/dynamic-rendering */ \"(app-pages-browser)/./node_modules/next/dist/server/app-render/dynamic-rendering.js\");\nconst _workunitasyncstorageexternal = __webpack_require__(/*! ../app-render/work-unit-async-storage.external */ \"(shared)/./node_modules/next/dist/server/app-render/work-unit-async-storage.external.js?4d57\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\");\nconst _utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/next/dist/server/request/utils.js\");\nconst _dynamicrenderingutils = __webpack_require__(/*! ../dynamic-rendering-utils */ \"(app-pages-browser)/./node_modules/next/dist/server/dynamic-rendering-utils.js\");\nconst _creatededupedbycallsiteservererrorlogger = __webpack_require__(/*! ../create-deduped-by-callsite-server-error-logger */ \"(app-pages-browser)/./node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js\");\nconst _scheduler = __webpack_require__(/*! ../../lib/scheduler */ \"(app-pages-browser)/./node_modules/next/dist/lib/scheduler.js\");\nfunction createParamsFromClient(underlyingParams, workStore) {\n    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createPrerenderParams(underlyingParams, workStore, workUnitStore);\n            default:\n        }\n    }\n    return createRenderParams(underlyingParams, workStore);\n}\nconst createServerParamsForMetadata = createServerParamsForServerSegment;\nfunction createServerParamsForRoute(underlyingParams, workStore) {\n    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createPrerenderParams(underlyingParams, workStore, workUnitStore);\n            default:\n        }\n    }\n    return createRenderParams(underlyingParams, workStore);\n}\nfunction createServerParamsForServerSegment(underlyingParams, workStore) {\n    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createPrerenderParams(underlyingParams, workStore, workUnitStore);\n            default:\n        }\n    }\n    return createRenderParams(underlyingParams, workStore);\n}\nfunction createPrerenderParamsForClientSegment(underlyingParams, workStore) {\n    const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (prerenderStore && prerenderStore.type === 'prerender') {\n        const fallbackParams = workStore.fallbackRouteParams;\n        if (fallbackParams) {\n            for(let key in underlyingParams){\n                if (fallbackParams.has(key)) {\n                    // This params object has one of more fallback params so we need to consider\n                    // the awaiting of this params object \"dynamic\". Since we are in dynamicIO mode\n                    // we encode this as a promise that never resolves\n                    return (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`params`');\n                }\n            }\n        }\n    }\n    // We're prerendering in a mode that does not abort. We resolve the promise without\n    // any tracking because we're just transporting a value from server to client where the tracking\n    // will be applied.\n    return Promise.resolve(underlyingParams);\n}\nfunction createPrerenderParams(underlyingParams, workStore, prerenderStore) {\n    const fallbackParams = workStore.fallbackRouteParams;\n    if (fallbackParams) {\n        let hasSomeFallbackParams = false;\n        for(const key in underlyingParams){\n            if (fallbackParams.has(key)) {\n                hasSomeFallbackParams = true;\n                break;\n            }\n        }\n        if (hasSomeFallbackParams) {\n            // params need to be treated as dynamic because we have at least one fallback param\n            if (prerenderStore.type === 'prerender') {\n                // We are in a dynamicIO (PPR or otherwise) prerender\n                return makeAbortingExoticParams(underlyingParams, workStore.route, prerenderStore);\n            }\n            // remaining cases are prender-ppr and prerender-legacy\n            // We aren't in a dynamicIO prerender but we do have fallback params at this\n            // level so we need to make an erroring exotic params object which will postpone\n            // if you access the fallback params\n            return makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore);\n        }\n    }\n    // We don't have any fallback params so we have an entirely static safe params object\n    return makeUntrackedExoticParams(underlyingParams);\n}\nfunction createRenderParams(underlyingParams, workStore) {\n    if ( true && !workStore.isPrefetchRequest) {\n        return makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, workStore);\n    } else {\n        return makeUntrackedExoticParams(underlyingParams);\n    }\n}\nconst CachedParams = new WeakMap();\nfunction makeAbortingExoticParams(underlyingParams, route, prerenderStore) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    const promise = (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`params`');\n    CachedParams.set(underlyingParams, promise);\n    Object.keys(underlyingParams).forEach((prop)=>{\n        if (_utils.wellKnownProperties.has(prop)) {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        } else {\n            Object.defineProperty(promise, prop, {\n                get () {\n                    const expression = (0, _utils.describeStringPropertyAccess)('params', prop);\n                    const error = createParamsAccessError(route, expression);\n                    (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(route, expression, error, prerenderStore);\n                },\n                set (newValue) {\n                    Object.defineProperty(promise, prop, {\n                        value: newValue,\n                        writable: true,\n                        enumerable: true\n                    });\n                },\n                enumerable: true,\n                configurable: true\n            });\n        }\n    });\n    return promise;\n}\nfunction makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    const augmentedUnderlying = {\n        ...underlyingParams\n    };\n    // We don't use makeResolvedReactPromise here because params\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = Promise.resolve(augmentedUnderlying);\n    CachedParams.set(underlyingParams, promise);\n    Object.keys(underlyingParams).forEach((prop)=>{\n        if (_utils.wellKnownProperties.has(prop)) {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        } else {\n            if (fallbackParams.has(prop)) {\n                Object.defineProperty(augmentedUnderlying, prop, {\n                    get () {\n                        const expression = (0, _utils.describeStringPropertyAccess)('params', prop);\n                        // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n                        // for params is only dynamic when we're generating a fallback shell\n                        // and even when `dynamic = \"error\"` we still support generating dynamic\n                        // fallback shells\n                        // TODO remove this comment when dynamicIO is the default since there\n                        // will be no `dynamic = \"error\"`\n                        if (prerenderStore.type === 'prerender-ppr') {\n                            // PPR Prerender (no dynamicIO)\n                            (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n                        } else {\n                            // Legacy Prerender\n                            (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n                        }\n                    },\n                    enumerable: true\n                });\n                Object.defineProperty(promise, prop, {\n                    get () {\n                        const expression = (0, _utils.describeStringPropertyAccess)('params', prop);\n                        // In most dynamic APIs we also throw if `dynamic = \"error\"` however\n                        // for params is only dynamic when we're generating a fallback shell\n                        // and even when `dynamic = \"error\"` we still support generating dynamic\n                        // fallback shells\n                        // TODO remove this comment when dynamicIO is the default since there\n                        // will be no `dynamic = \"error\"`\n                        if (prerenderStore.type === 'prerender-ppr') {\n                            // PPR Prerender (no dynamicIO)\n                            (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n                        } else {\n                            // Legacy Prerender\n                            (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n                        }\n                    },\n                    set (newValue) {\n                        Object.defineProperty(promise, prop, {\n                            value: newValue,\n                            writable: true,\n                            enumerable: true\n                        });\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n            } else {\n                ;\n                promise[prop] = underlyingParams[prop];\n            }\n        }\n    });\n    return promise;\n}\nfunction makeUntrackedExoticParams(underlyingParams) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    // We don't use makeResolvedReactPromise here because params\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = Promise.resolve(underlyingParams);\n    CachedParams.set(underlyingParams, promise);\n    Object.keys(underlyingParams).forEach((prop)=>{\n        if (_utils.wellKnownProperties.has(prop)) {\n        // These properties cannot be shadowed because they need to be the\n        // true underlying value for Promises to work correctly at runtime\n        } else {\n            ;\n            promise[prop] = underlyingParams[prop];\n        }\n    });\n    return promise;\n}\nfunction makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, store) {\n    const cachedParams = CachedParams.get(underlyingParams);\n    if (cachedParams) {\n        return cachedParams;\n    }\n    // We don't use makeResolvedReactPromise here because params\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = new Promise((resolve)=>(0, _scheduler.scheduleImmediate)(()=>resolve(underlyingParams)));\n    const proxiedProperties = new Set();\n    const unproxiedProperties = [];\n    Object.keys(underlyingParams).forEach((prop)=>{\n        if (_utils.wellKnownProperties.has(prop)) {\n            // These properties cannot be shadowed because they need to be the\n            // true underlying value for Promises to work correctly at runtime\n            unproxiedProperties.push(prop);\n        } else {\n            proxiedProperties.add(prop);\n            promise[prop] = underlyingParams[prop];\n        }\n    });\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            if (typeof prop === 'string') {\n                if (// We are accessing a property that was proxied to the promise instance\n                proxiedProperties.has(prop)) {\n                    const expression = (0, _utils.describeStringPropertyAccess)('params', prop);\n                    syncIODev(store.route, expression);\n                }\n            }\n            return _reflect.ReflectAdapter.get(target, prop, receiver);\n        },\n        set (target, prop, value, receiver) {\n            if (typeof prop === 'string') {\n                proxiedProperties.delete(prop);\n            }\n            return _reflect.ReflectAdapter.set(target, prop, value, receiver);\n        },\n        ownKeys (target) {\n            const expression = '`...params` or similar expression';\n            syncIODev(store.route, expression, unproxiedProperties);\n            return Reflect.ownKeys(target);\n        }\n    });\n    CachedParams.set(underlyingParams, proxiedPromise);\n    return proxiedPromise;\n}\nfunction syncIODev(route, expression, missingProperties) {\n    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {\n        // When we're rendering dynamically in dev we need to advance out of the\n        // Prerender environment when we read Request data synchronously\n        const requestStore = workUnitStore;\n        (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(requestStore);\n    }\n    // In all cases we warn normally\n    if (missingProperties && missingProperties.length > 0) {\n        warnForIncompleteEnumeration(route, expression, missingProperties);\n    } else {\n        warnForSyncAccess(route, expression);\n    }\n}\nconst noop = ()=>{};\nconst warnForSyncAccess =  false ? 0 : (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createParamsAccessError);\nconst warnForIncompleteEnumeration =  false ? 0 : (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createIncompleteEnumerationError);\nfunction createParamsAccessError(route, expression) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return new Error(`${prefix}used ${expression}. ` + `\\`params\\` should be awaited before using its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n}\nfunction createIncompleteEnumerationError(route, expression, missingProperties) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return new Error(`${prefix}used ${expression}. ` + `\\`params\\` should be awaited before using its properties. ` + `The following properties were not available through enumeration ` + `because they conflict with builtin property names: ` + `${describeListOfPropertyNames(missingProperties)}. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n}\nfunction describeListOfPropertyNames(properties) {\n    switch(properties.length){\n        case 0:\n            throw new _invarianterror.InvariantError('Expected describeListOfPropertyNames to be called with a non-empty list of strings.');\n        case 1:\n            return `\\`${properties[0]}\\``;\n        case 2:\n            return `\\`${properties[0]}\\` and \\`${properties[1]}\\``;\n        default:\n            {\n                let description = '';\n                for(let i = 0; i < properties.length - 1; i++){\n                    description += `\\`${properties[i]}\\`, `;\n                }\n                description += `, and \\`${properties[properties.length - 1]}\\``;\n                return description;\n            }\n    }\n}\n\n//# sourceMappingURL=params.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3QvcGFyYW1zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsTUFBTSxDQU1MO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQixtQkFBTyxDQUFDLDBJQUF3QztBQUNqRSwwQkFBMEIsbUJBQU8sQ0FBQyw0SEFBaUM7QUFDbkUsc0NBQXNDLG1CQUFPLENBQUMsb0pBQWdEO0FBQzlGLHdCQUF3QixtQkFBTyxDQUFDLG9IQUFrQztBQUNsRSxlQUFlLG1CQUFPLENBQUMscUZBQVM7QUFDaEMsK0JBQStCLG1CQUFPLENBQUMsa0hBQTRCO0FBQ25FLGtEQUFrRCxtQkFBTyxDQUFDLGdLQUFtRDtBQUM3RyxtQkFBbUIsbUJBQU8sQ0FBQywwRkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFzQztBQUM5QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQW9ELEdBQUcsQ0FBSTtBQUNyRixxQ0FBcUMsTUFBb0QsR0FBRyxDQUFJO0FBQ2hHO0FBQ0EscUNBQXFDLE1BQU07QUFDM0Msd0JBQXdCLE9BQU8sT0FBTyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQSxxQ0FBcUMsTUFBTTtBQUMzQyx3QkFBd0IsT0FBTyxPQUFPLFdBQVcscU1BQXFNLCtDQUErQztBQUNyUztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBLHdCQUF3QixjQUFjLFdBQVcsY0FBYztBQUMvRDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkJBQTJCO0FBQzFELHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0EsMENBQTBDLGtDQUFrQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxIb21lXFxEZXNrdG9wXFxueHRwcm9qZWN0XFxub2RlX21vZHVsZXNcXG5leHRcXGRpc3RcXHNlcnZlclxccmVxdWVzdFxccGFyYW1zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY3JlYXRlUGFyYW1zRnJvbUNsaWVudDogbnVsbCxcbiAgICBjcmVhdGVQcmVyZW5kZXJQYXJhbXNGb3JDbGllbnRTZWdtZW50OiBudWxsLFxuICAgIGNyZWF0ZVNlcnZlclBhcmFtc0Zvck1ldGFkYXRhOiBudWxsLFxuICAgIGNyZWF0ZVNlcnZlclBhcmFtc0ZvclJvdXRlOiBudWxsLFxuICAgIGNyZWF0ZVNlcnZlclBhcmFtc0ZvclNlcnZlclNlZ21lbnQ6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgY3JlYXRlUGFyYW1zRnJvbUNsaWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQYXJhbXNGcm9tQ2xpZW50O1xuICAgIH0sXG4gICAgY3JlYXRlUHJlcmVuZGVyUGFyYW1zRm9yQ2xpZW50U2VnbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQcmVyZW5kZXJQYXJhbXNGb3JDbGllbnRTZWdtZW50O1xuICAgIH0sXG4gICAgY3JlYXRlU2VydmVyUGFyYW1zRm9yTWV0YWRhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2VydmVyUGFyYW1zRm9yTWV0YWRhdGE7XG4gICAgfSxcbiAgICBjcmVhdGVTZXJ2ZXJQYXJhbXNGb3JSb3V0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTZXJ2ZXJQYXJhbXNGb3JSb3V0ZTtcbiAgICB9LFxuICAgIGNyZWF0ZVNlcnZlclBhcmFtc0ZvclNlcnZlclNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2VydmVyUGFyYW1zRm9yU2VydmVyU2VnbWVudDtcbiAgICB9XG59KTtcbmNvbnN0IF9yZWZsZWN0ID0gcmVxdWlyZShcIi4uL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZWZsZWN0XCIpO1xuY29uc3QgX2R5bmFtaWNyZW5kZXJpbmcgPSByZXF1aXJlKFwiLi4vYXBwLXJlbmRlci9keW5hbWljLXJlbmRlcmluZ1wiKTtcbmNvbnN0IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsID0gcmVxdWlyZShcIi4uL2FwcC1yZW5kZXIvd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWxcIik7XG5jb25zdCBfaW52YXJpYW50ZXJyb3IgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3JcIik7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IF9keW5hbWljcmVuZGVyaW5ndXRpbHMgPSByZXF1aXJlKFwiLi4vZHluYW1pYy1yZW5kZXJpbmctdXRpbHNcIik7XG5jb25zdCBfY3JlYXRlZGVkdXBlZGJ5Y2FsbHNpdGVzZXJ2ZXJlcnJvcmxvZ2dlciA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtZGVkdXBlZC1ieS1jYWxsc2l0ZS1zZXJ2ZXItZXJyb3ItbG9nZ2VyXCIpO1xuY29uc3QgX3NjaGVkdWxlciA9IHJlcXVpcmUoXCIuLi8uLi9saWIvc2NoZWR1bGVyXCIpO1xuZnVuY3Rpb24gY3JlYXRlUGFyYW1zRnJvbUNsaWVudCh1bmRlcmx5aW5nUGFyYW1zLCB3b3JrU3RvcmUpIHtcbiAgICBjb25zdCB3b3JrVW5pdFN0b3JlID0gX3dvcmt1bml0YXN5bmNzdG9yYWdlZXh0ZXJuYWwud29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgICAgICBzd2l0Y2god29ya1VuaXRTdG9yZS50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXItcHByJzpcbiAgICAgICAgICAgIGNhc2UgJ3ByZXJlbmRlci1sZWdhY3knOlxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcmVyZW5kZXJQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlLCB3b3JrVW5pdFN0b3JlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJlbmRlclBhcmFtcyh1bmRlcmx5aW5nUGFyYW1zLCB3b3JrU3RvcmUpO1xufVxuY29uc3QgY3JlYXRlU2VydmVyUGFyYW1zRm9yTWV0YWRhdGEgPSBjcmVhdGVTZXJ2ZXJQYXJhbXNGb3JTZXJ2ZXJTZWdtZW50O1xuZnVuY3Rpb24gY3JlYXRlU2VydmVyUGFyYW1zRm9yUm91dGUodW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKSB7XG4gICAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsLndvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgICAgc3dpdGNoKHdvcmtVbml0U3RvcmUudHlwZSl7XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgICAgICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJlcmVuZGVyUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSZW5kZXJQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlclBhcmFtc0ZvclNlcnZlclNlZ21lbnQodW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKSB7XG4gICAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsLndvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgICAgc3dpdGNoKHdvcmtVbml0U3RvcmUudHlwZSl7XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgICAgICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJlcmVuZGVyUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSZW5kZXJQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByZXJlbmRlclBhcmFtc0ZvckNsaWVudFNlZ21lbnQodW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKSB7XG4gICAgY29uc3QgcHJlcmVuZGVyU3RvcmUgPSBfd29ya3VuaXRhc3luY3N0b3JhZ2VleHRlcm5hbC53b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGlmIChwcmVyZW5kZXJTdG9yZSAmJiBwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyJykge1xuICAgICAgICBjb25zdCBmYWxsYmFja1BhcmFtcyA9IHdvcmtTdG9yZS5mYWxsYmFja1JvdXRlUGFyYW1zO1xuICAgICAgICBpZiAoZmFsbGJhY2tQYXJhbXMpIHtcbiAgICAgICAgICAgIGZvcihsZXQga2V5IGluIHVuZGVybHlpbmdQYXJhbXMpe1xuICAgICAgICAgICAgICAgIGlmIChmYWxsYmFja1BhcmFtcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHBhcmFtcyBvYmplY3QgaGFzIG9uZSBvZiBtb3JlIGZhbGxiYWNrIHBhcmFtcyBzbyB3ZSBuZWVkIHRvIGNvbnNpZGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhd2FpdGluZyBvZiB0aGlzIHBhcmFtcyBvYmplY3QgXCJkeW5hbWljXCIuIFNpbmNlIHdlIGFyZSBpbiBkeW5hbWljSU8gbW9kZVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBlbmNvZGUgdGhpcyBhcyBhIHByb21pc2UgdGhhdCBuZXZlciByZXNvbHZlc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9keW5hbWljcmVuZGVyaW5ndXRpbHMubWFrZUhhbmdpbmdQcm9taXNlKShwcmVyZW5kZXJTdG9yZS5yZW5kZXJTaWduYWwsICdgcGFyYW1zYCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSdyZSBwcmVyZW5kZXJpbmcgaW4gYSBtb2RlIHRoYXQgZG9lcyBub3QgYWJvcnQuIFdlIHJlc29sdmUgdGhlIHByb21pc2Ugd2l0aG91dFxuICAgIC8vIGFueSB0cmFja2luZyBiZWNhdXNlIHdlJ3JlIGp1c3QgdHJhbnNwb3J0aW5nIGEgdmFsdWUgZnJvbSBzZXJ2ZXIgdG8gY2xpZW50IHdoZXJlIHRoZSB0cmFja2luZ1xuICAgIC8vIHdpbGwgYmUgYXBwbGllZC5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVuZGVybHlpbmdQYXJhbXMpO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJlcmVuZGVyUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpIHtcbiAgICBjb25zdCBmYWxsYmFja1BhcmFtcyA9IHdvcmtTdG9yZS5mYWxsYmFja1JvdXRlUGFyYW1zO1xuICAgIGlmIChmYWxsYmFja1BhcmFtcykge1xuICAgICAgICBsZXQgaGFzU29tZUZhbGxiYWNrUGFyYW1zID0gZmFsc2U7XG4gICAgICAgIGZvcihjb25zdCBrZXkgaW4gdW5kZXJseWluZ1BhcmFtcyl7XG4gICAgICAgICAgICBpZiAoZmFsbGJhY2tQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBoYXNTb21lRmFsbGJhY2tQYXJhbXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNTb21lRmFsbGJhY2tQYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIHBhcmFtcyBuZWVkIHRvIGJlIHRyZWF0ZWQgYXMgZHluYW1pYyBiZWNhdXNlIHdlIGhhdmUgYXQgbGVhc3Qgb25lIGZhbGxiYWNrIHBhcmFtXG4gICAgICAgICAgICBpZiAocHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlcicpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgaW4gYSBkeW5hbWljSU8gKFBQUiBvciBvdGhlcndpc2UpIHByZXJlbmRlclxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlQWJvcnRpbmdFeG90aWNQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlLnJvdXRlLCBwcmVyZW5kZXJTdG9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW1haW5pbmcgY2FzZXMgYXJlIHByZW5kZXItcHByIGFuZCBwcmVyZW5kZXItbGVnYWN5XG4gICAgICAgICAgICAvLyBXZSBhcmVuJ3QgaW4gYSBkeW5hbWljSU8gcHJlcmVuZGVyIGJ1dCB3ZSBkbyBoYXZlIGZhbGxiYWNrIHBhcmFtcyBhdCB0aGlzXG4gICAgICAgICAgICAvLyBsZXZlbCBzbyB3ZSBuZWVkIHRvIG1ha2UgYW4gZXJyb3JpbmcgZXhvdGljIHBhcmFtcyBvYmplY3Qgd2hpY2ggd2lsbCBwb3N0cG9uZVxuICAgICAgICAgICAgLy8gaWYgeW91IGFjY2VzcyB0aGUgZmFsbGJhY2sgcGFyYW1zXG4gICAgICAgICAgICByZXR1cm4gbWFrZUVycm9yaW5nRXhvdGljUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIGZhbGxiYWNrUGFyYW1zLCB3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBkb24ndCBoYXZlIGFueSBmYWxsYmFjayBwYXJhbXMgc28gd2UgaGF2ZSBhbiBlbnRpcmVseSBzdGF0aWMgc2FmZSBwYXJhbXMgb2JqZWN0XG4gICAgcmV0dXJuIG1ha2VVbnRyYWNrZWRFeG90aWNQYXJhbXModW5kZXJseWluZ1BhcmFtcyk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJQYXJhbXModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICF3b3JrU3RvcmUuaXNQcmVmZXRjaFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VEeW5hbWljYWxseVRyYWNrZWRFeG90aWNQYXJhbXNXaXRoRGV2V2FybmluZ3ModW5kZXJseWluZ1BhcmFtcywgd29ya1N0b3JlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWFrZVVudHJhY2tlZEV4b3RpY1BhcmFtcyh1bmRlcmx5aW5nUGFyYW1zKTtcbiAgICB9XG59XG5jb25zdCBDYWNoZWRQYXJhbXMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gbWFrZUFib3J0aW5nRXhvdGljUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIHJvdXRlLCBwcmVyZW5kZXJTdG9yZSkge1xuICAgIGNvbnN0IGNhY2hlZFBhcmFtcyA9IENhY2hlZFBhcmFtcy5nZXQodW5kZXJseWluZ1BhcmFtcyk7XG4gICAgaWYgKGNhY2hlZFBhcmFtcykge1xuICAgICAgICByZXR1cm4gY2FjaGVkUGFyYW1zO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gKDAsIF9keW5hbWljcmVuZGVyaW5ndXRpbHMubWFrZUhhbmdpbmdQcm9taXNlKShwcmVyZW5kZXJTdG9yZS5yZW5kZXJTaWduYWwsICdgcGFyYW1zYCcpO1xuICAgIENhY2hlZFBhcmFtcy5zZXQodW5kZXJseWluZ1BhcmFtcywgcHJvbWlzZSk7XG4gICAgT2JqZWN0LmtleXModW5kZXJseWluZ1BhcmFtcykuZm9yRWFjaCgocHJvcCk9PntcbiAgICAgICAgaWYgKF91dGlscy53ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBzaGFkb3dlZCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSB0aGVcbiAgICAgICAgLy8gdHJ1ZSB1bmRlcmx5aW5nIHZhbHVlIGZvciBQcm9taXNlcyB0byB3b3JrIGNvcnJlY3RseSBhdCBydW50aW1lXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgcHJvcCwge1xuICAgICAgICAgICAgICAgIGdldCAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MpKCdwYXJhbXMnLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBjcmVhdGVQYXJhbXNBY2Nlc3NFcnJvcihyb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5hYm9ydEFuZFRocm93T25TeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzKShyb3V0ZSwgZXhwcmVzc2lvbiwgZXJyb3IsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldCAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIHByb3AsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gbWFrZUVycm9yaW5nRXhvdGljUGFyYW1zKHVuZGVybHlpbmdQYXJhbXMsIGZhbGxiYWNrUGFyYW1zLCB3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKSB7XG4gICAgY29uc3QgY2FjaGVkUGFyYW1zID0gQ2FjaGVkUGFyYW1zLmdldCh1bmRlcmx5aW5nUGFyYW1zKTtcbiAgICBpZiAoY2FjaGVkUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRQYXJhbXM7XG4gICAgfVxuICAgIGNvbnN0IGF1Z21lbnRlZFVuZGVybHlpbmcgPSB7XG4gICAgICAgIC4uLnVuZGVybHlpbmdQYXJhbXNcbiAgICB9O1xuICAgIC8vIFdlIGRvbid0IHVzZSBtYWtlUmVzb2x2ZWRSZWFjdFByb21pc2UgaGVyZSBiZWNhdXNlIHBhcmFtc1xuICAgIC8vIHN1cHBvcnRzIGNvcHlpbmcgd2l0aCBzcHJlYWQgYW5kIHdlIGRvbid0IHdhbnQgdG8gdW5uZWNlc3NhcmlseVxuICAgIC8vIGluc3RydW1lbnQgdGhlIHByb21pc2Ugd2l0aCBzcHJlYWRhYmxlIHByb3BlcnRpZXMgb2YgUmVhY3RQcm9taXNlLlxuICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoYXVnbWVudGVkVW5kZXJseWluZyk7XG4gICAgQ2FjaGVkUGFyYW1zLnNldCh1bmRlcmx5aW5nUGFyYW1zLCBwcm9taXNlKTtcbiAgICBPYmplY3Qua2V5cyh1bmRlcmx5aW5nUGFyYW1zKS5mb3JFYWNoKChwcm9wKT0+e1xuICAgICAgICBpZiAoX3V0aWxzLndlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY2Fubm90IGJlIHNoYWRvd2VkIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIHRoZVxuICAgICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmYWxsYmFja1BhcmFtcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXVnbWVudGVkVW5kZXJseWluZywgcHJvcCwge1xuICAgICAgICAgICAgICAgICAgICBnZXQgKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcykoJ3BhcmFtcycsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gbW9zdCBkeW5hbWljIEFQSXMgd2UgYWxzbyB0aHJvdyBpZiBgZHluYW1pYyA9IFwiZXJyb3JcImAgaG93ZXZlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHBhcmFtcyBpcyBvbmx5IGR5bmFtaWMgd2hlbiB3ZSdyZSBnZW5lcmF0aW5nIGEgZmFsbGJhY2sgc2hlbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBldmVuIHdoZW4gYGR5bmFtaWMgPSBcImVycm9yXCJgIHdlIHN0aWxsIHN1cHBvcnQgZ2VuZXJhdGluZyBkeW5hbWljXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWxsYmFjayBzaGVsbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgY29tbWVudCB3aGVuIGR5bmFtaWNJTyBpcyB0aGUgZGVmYXVsdCBzaW5jZSB0aGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBiZSBubyBgZHluYW1pYyA9IFwiZXJyb3JcImBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLXBwcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQUFIgUHJlcmVuZGVyIChubyBkeW5hbWljSU8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnBvc3Rwb25lV2l0aFRyYWNraW5nKSh3b3JrU3RvcmUucm91dGUsIGV4cHJlc3Npb24sIHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBQcmVyZW5kZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24pKGV4cHJlc3Npb24sIHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIHByb3AsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0ICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MpKCdwYXJhbXMnLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIG1vc3QgZHluYW1pYyBBUElzIHdlIGFsc28gdGhyb3cgaWYgYGR5bmFtaWMgPSBcImVycm9yXCJgIGhvd2V2ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBwYXJhbXMgaXMgb25seSBkeW5hbWljIHdoZW4gd2UncmUgZ2VuZXJhdGluZyBhIGZhbGxiYWNrIHNoZWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgZXZlbiB3aGVuIGBkeW5hbWljID0gXCJlcnJvclwiYCB3ZSBzdGlsbCBzdXBwb3J0IGdlbmVyYXRpbmcgZHluYW1pY1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFsbGJhY2sgc2hlbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlbW92ZSB0aGlzIGNvbW1lbnQgd2hlbiBkeW5hbWljSU8gaXMgdGhlIGRlZmF1bHQgc2luY2UgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgbm8gYGR5bmFtaWMgPSBcImVycm9yXCJgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUFBSIFByZXJlbmRlciAobm8gZHluYW1pY0lPKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5wb3N0cG9uZVdpdGhUcmFja2luZykod29ya1N0b3JlLnJvdXRlLCBleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZWdhY3kgUHJlcmVuZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKShleHByZXNzaW9uLCB3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0IChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIHByb3AsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgcHJvbWlzZVtwcm9wXSA9IHVuZGVybHlpbmdQYXJhbXNbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIG1ha2VVbnRyYWNrZWRFeG90aWNQYXJhbXModW5kZXJseWluZ1BhcmFtcykge1xuICAgIGNvbnN0IGNhY2hlZFBhcmFtcyA9IENhY2hlZFBhcmFtcy5nZXQodW5kZXJseWluZ1BhcmFtcyk7XG4gICAgaWYgKGNhY2hlZFBhcmFtcykge1xuICAgICAgICByZXR1cm4gY2FjaGVkUGFyYW1zO1xuICAgIH1cbiAgICAvLyBXZSBkb24ndCB1c2UgbWFrZVJlc29sdmVkUmVhY3RQcm9taXNlIGhlcmUgYmVjYXVzZSBwYXJhbXNcbiAgICAvLyBzdXBwb3J0cyBjb3B5aW5nIHdpdGggc3ByZWFkIGFuZCB3ZSBkb24ndCB3YW50IHRvIHVubmVjZXNzYXJpbHlcbiAgICAvLyBpbnN0cnVtZW50IHRoZSBwcm9taXNlIHdpdGggc3ByZWFkYWJsZSBwcm9wZXJ0aWVzIG9mIFJlYWN0UHJvbWlzZS5cbiAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVybHlpbmdQYXJhbXMpO1xuICAgIENhY2hlZFBhcmFtcy5zZXQodW5kZXJseWluZ1BhcmFtcywgcHJvbWlzZSk7XG4gICAgT2JqZWN0LmtleXModW5kZXJseWluZ1BhcmFtcykuZm9yRWFjaCgocHJvcCk9PntcbiAgICAgICAgaWYgKF91dGlscy53ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBzaGFkb3dlZCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSB0aGVcbiAgICAgICAgLy8gdHJ1ZSB1bmRlcmx5aW5nIHZhbHVlIGZvciBQcm9taXNlcyB0byB3b3JrIGNvcnJlY3RseSBhdCBydW50aW1lXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBwcm9taXNlW3Byb3BdID0gdW5kZXJseWluZ1BhcmFtc1twcm9wXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gbWFrZUR5bmFtaWNhbGx5VHJhY2tlZEV4b3RpY1BhcmFtc1dpdGhEZXZXYXJuaW5ncyh1bmRlcmx5aW5nUGFyYW1zLCBzdG9yZSkge1xuICAgIGNvbnN0IGNhY2hlZFBhcmFtcyA9IENhY2hlZFBhcmFtcy5nZXQodW5kZXJseWluZ1BhcmFtcyk7XG4gICAgaWYgKGNhY2hlZFBhcmFtcykge1xuICAgICAgICByZXR1cm4gY2FjaGVkUGFyYW1zO1xuICAgIH1cbiAgICAvLyBXZSBkb24ndCB1c2UgbWFrZVJlc29sdmVkUmVhY3RQcm9taXNlIGhlcmUgYmVjYXVzZSBwYXJhbXNcbiAgICAvLyBzdXBwb3J0cyBjb3B5aW5nIHdpdGggc3ByZWFkIGFuZCB3ZSBkb24ndCB3YW50IHRvIHVubmVjZXNzYXJpbHlcbiAgICAvLyBpbnN0cnVtZW50IHRoZSBwcm9taXNlIHdpdGggc3ByZWFkYWJsZSBwcm9wZXJ0aWVzIG9mIFJlYWN0UHJvbWlzZS5cbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT4oMCwgX3NjaGVkdWxlci5zY2hlZHVsZUltbWVkaWF0ZSkoKCk9PnJlc29sdmUodW5kZXJseWluZ1BhcmFtcykpKTtcbiAgICBjb25zdCBwcm94aWVkUHJvcGVydGllcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1bnByb3hpZWRQcm9wZXJ0aWVzID0gW107XG4gICAgT2JqZWN0LmtleXModW5kZXJseWluZ1BhcmFtcykuZm9yRWFjaCgocHJvcCk9PntcbiAgICAgICAgaWYgKF91dGlscy53ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBjYW5ub3QgYmUgc2hhZG93ZWQgYmVjYXVzZSB0aGV5IG5lZWQgdG8gYmUgdGhlXG4gICAgICAgICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICAgICAgICAgIHVucHJveGllZFByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgICAgIHByb21pc2VbcHJvcF0gPSB1bmRlcmx5aW5nUGFyYW1zW3Byb3BdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgICAgICBnZXQgKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAoLy8gV2UgYXJlIGFjY2Vzc2luZyBhIHByb3BlcnR5IHRoYXQgd2FzIHByb3hpZWQgdG8gdGhlIHByb21pc2UgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICBwcm94aWVkUHJvcGVydGllcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcykoJ3BhcmFtcycsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICBzeW5jSU9EZXYoc3RvcmUucm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCAodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwcm94aWVkUHJvcGVydGllcy5kZWxldGUocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3JlZmxlY3QuUmVmbGVjdEFkYXB0ZXIuc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgb3duS2V5cyAodGFyZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2AuLi5wYXJhbXNgIG9yIHNpbWlsYXIgZXhwcmVzc2lvbic7XG4gICAgICAgICAgICBzeW5jSU9EZXYoc3RvcmUucm91dGUsIGV4cHJlc3Npb24sIHVucHJveGllZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgQ2FjaGVkUGFyYW1zLnNldCh1bmRlcmx5aW5nUGFyYW1zLCBwcm94aWVkUHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb3hpZWRQcm9taXNlO1xufVxuZnVuY3Rpb24gc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uLCBtaXNzaW5nUHJvcGVydGllcykge1xuICAgIGNvbnN0IHdvcmtVbml0U3RvcmUgPSBfd29ya3VuaXRhc3luY3N0b3JhZ2VleHRlcm5hbC53b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGlmICh3b3JrVW5pdFN0b3JlICYmIHdvcmtVbml0U3RvcmUudHlwZSA9PT0gJ3JlcXVlc3QnICYmIHdvcmtVbml0U3RvcmUucHJlcmVuZGVyUGhhc2UgPT09IHRydWUpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSdyZSByZW5kZXJpbmcgZHluYW1pY2FsbHkgaW4gZGV2IHdlIG5lZWQgdG8gYWR2YW5jZSBvdXQgb2YgdGhlXG4gICAgICAgIC8vIFByZXJlbmRlciBlbnZpcm9ubWVudCB3aGVuIHdlIHJlYWQgUmVxdWVzdCBkYXRhIHN5bmNocm9ub3VzbHlcbiAgICAgICAgY29uc3QgcmVxdWVzdFN0b3JlID0gd29ya1VuaXRTdG9yZTtcbiAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2KShyZXF1ZXN0U3RvcmUpO1xuICAgIH1cbiAgICAvLyBJbiBhbGwgY2FzZXMgd2Ugd2FybiBub3JtYWxseVxuICAgIGlmIChtaXNzaW5nUHJvcGVydGllcyAmJiBtaXNzaW5nUHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHdhcm5Gb3JJbmNvbXBsZXRlRW51bWVyYXRpb24ocm91dGUsIGV4cHJlc3Npb24sIG1pc3NpbmdQcm9wZXJ0aWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuRm9yU3luY0FjY2Vzcyhyb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgfVxufVxuY29uc3Qgbm9vcCA9ICgpPT57fTtcbmNvbnN0IHdhcm5Gb3JTeW5jQWNjZXNzID0gcHJvY2Vzcy5lbnYuX19ORVhUX0RJU0FCTEVfU1lOQ19EWU5BTUlDX0FQSV9XQVJOSU5HUyA/IG5vb3AgOiAoMCwgX2NyZWF0ZWRlZHVwZWRieWNhbGxzaXRlc2VydmVyZXJyb3Jsb2dnZXIuY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldikoY3JlYXRlUGFyYW1zQWNjZXNzRXJyb3IpO1xuY29uc3Qgd2FybkZvckluY29tcGxldGVFbnVtZXJhdGlvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ESVNBQkxFX1NZTkNfRFlOQU1JQ19BUElfV0FSTklOR1MgPyBub29wIDogKDAsIF9jcmVhdGVkZWR1cGVkYnljYWxsc2l0ZXNlcnZlcmVycm9ybG9nZ2VyLmNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYpKGNyZWF0ZUluY29tcGxldGVFbnVtZXJhdGlvbkVycm9yKTtcbmZ1bmN0aW9uIGNyZWF0ZVBhcmFtc0FjY2Vzc0Vycm9yKHJvdXRlLCBleHByZXNzaW9uKSB7XG4gICAgY29uc3QgcHJlZml4ID0gcm91dGUgPyBgUm91dGUgXCIke3JvdXRlfVwiIGAgOiAnVGhpcyByb3V0ZSAnO1xuICAgIHJldHVybiBuZXcgRXJyb3IoYCR7cHJlZml4fXVzZWQgJHtleHByZXNzaW9ufS4gYCArIGBcXGBwYXJhbXNcXGAgc2hvdWxkIGJlIGF3YWl0ZWQgYmVmb3JlIHVzaW5nIGl0cyBwcm9wZXJ0aWVzLiBgICsgYExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3N5bmMtZHluYW1pYy1hcGlzYCk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbmNvbXBsZXRlRW51bWVyYXRpb25FcnJvcihyb3V0ZSwgZXhwcmVzc2lvbiwgbWlzc2luZ1Byb3BlcnRpZXMpIHtcbiAgICBjb25zdCBwcmVmaXggPSByb3V0ZSA/IGBSb3V0ZSBcIiR7cm91dGV9XCIgYCA6ICdUaGlzIHJvdXRlICc7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihgJHtwcmVmaXh9dXNlZCAke2V4cHJlc3Npb259LiBgICsgYFxcYHBhcmFtc1xcYCBzaG91bGQgYmUgYXdhaXRlZCBiZWZvcmUgdXNpbmcgaXRzIHByb3BlcnRpZXMuIGAgKyBgVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIHdlcmUgbm90IGF2YWlsYWJsZSB0aHJvdWdoIGVudW1lcmF0aW9uIGAgKyBgYmVjYXVzZSB0aGV5IGNvbmZsaWN0IHdpdGggYnVpbHRpbiBwcm9wZXJ0eSBuYW1lczogYCArIGAke2Rlc2NyaWJlTGlzdE9mUHJvcGVydHlOYW1lcyhtaXNzaW5nUHJvcGVydGllcyl9LiBgICsgYExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3N5bmMtZHluYW1pYy1hcGlzYCk7XG59XG5mdW5jdGlvbiBkZXNjcmliZUxpc3RPZlByb3BlcnR5TmFtZXMocHJvcGVydGllcykge1xuICAgIHN3aXRjaChwcm9wZXJ0aWVzLmxlbmd0aCl7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRocm93IG5ldyBfaW52YXJpYW50ZXJyb3IuSW52YXJpYW50RXJyb3IoJ0V4cGVjdGVkIGRlc2NyaWJlTGlzdE9mUHJvcGVydHlOYW1lcyB0byBiZSBjYWxsZWQgd2l0aCBhIG5vbi1lbXB0eSBsaXN0IG9mIHN0cmluZ3MuJyk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBgXFxgJHtwcm9wZXJ0aWVzWzBdfVxcYGA7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBgXFxgJHtwcm9wZXJ0aWVzWzBdfVxcYCBhbmQgXFxgJHtwcm9wZXJ0aWVzWzFdfVxcYGA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IGRlc2NyaXB0aW9uID0gJyc7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoIC0gMTsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gKz0gYFxcYCR7cHJvcGVydGllc1tpXX1cXGAsIGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uICs9IGAsIGFuZCBcXGAke3Byb3BlcnRpZXNbcHJvcGVydGllcy5sZW5ndGggLSAxXX1cXGBgO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcmFtcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/request/params.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/server/request/search-params.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/server/request/search-params.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createPrerenderSearchParamsForClientPage: function() {\n        return createPrerenderSearchParamsForClientPage;\n    },\n    createSearchParamsFromClient: function() {\n        return createSearchParamsFromClient;\n    },\n    createServerSearchParamsForMetadata: function() {\n        return createServerSearchParamsForMetadata;\n    },\n    createServerSearchParamsForServerPage: function() {\n        return createServerSearchParamsForServerPage;\n    }\n});\nconst _reflect = __webpack_require__(/*! ../web/spec-extension/adapters/reflect */ \"(app-pages-browser)/./node_modules/next/dist/server/web/spec-extension/adapters/reflect.js\");\nconst _dynamicrendering = __webpack_require__(/*! ../app-render/dynamic-rendering */ \"(app-pages-browser)/./node_modules/next/dist/server/app-render/dynamic-rendering.js\");\nconst _workunitasyncstorageexternal = __webpack_require__(/*! ../app-render/work-unit-async-storage.external */ \"(shared)/./node_modules/next/dist/server/app-render/work-unit-async-storage.external.js?4d57\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\");\nconst _dynamicrenderingutils = __webpack_require__(/*! ../dynamic-rendering-utils */ \"(app-pages-browser)/./node_modules/next/dist/server/dynamic-rendering-utils.js\");\nconst _creatededupedbycallsiteservererrorlogger = __webpack_require__(/*! ../create-deduped-by-callsite-server-error-logger */ \"(app-pages-browser)/./node_modules/next/dist/server/create-deduped-by-callsite-server-error-logger.js\");\nconst _utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/next/dist/server/request/utils.js\");\nconst _scheduler = __webpack_require__(/*! ../../lib/scheduler */ \"(app-pages-browser)/./node_modules/next/dist/lib/scheduler.js\");\nfunction createSearchParamsFromClient(underlyingSearchParams, workStore) {\n    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createPrerenderSearchParams(workStore, workUnitStore);\n            default:\n        }\n    }\n    return createRenderSearchParams(underlyingSearchParams, workStore);\n}\nconst createServerSearchParamsForMetadata = createServerSearchParamsForServerPage;\nfunction createServerSearchParamsForServerPage(underlyingSearchParams, workStore) {\n    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n                return createPrerenderSearchParams(workStore, workUnitStore);\n            default:\n        }\n    }\n    return createRenderSearchParams(underlyingSearchParams, workStore);\n}\nfunction createPrerenderSearchParamsForClientPage(workStore) {\n    if (workStore.forceStatic) {\n        // When using forceStatic we override all other logic and always just return an empty\n        // dictionary object.\n        return Promise.resolve({});\n    }\n    const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (prerenderStore && prerenderStore.type === 'prerender') {\n        // dynamicIO Prerender\n        // We're prerendering in a mode that aborts (dynamicIO) and should stall\n        // the promise to ensure the RSC side is considered dynamic\n        return (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`searchParams`');\n    }\n    // We're prerendering in a mode that does not aborts. We resolve the promise without\n    // any tracking because we're just transporting a value from server to client where the tracking\n    // will be applied.\n    return Promise.resolve({});\n}\nfunction createPrerenderSearchParams(workStore, prerenderStore) {\n    if (workStore.forceStatic) {\n        // When using forceStatic we override all other logic and always just return an empty\n        // dictionary object.\n        return Promise.resolve({});\n    }\n    if (prerenderStore.type === 'prerender') {\n        // We are in a dynamicIO (PPR or otherwise) prerender\n        return makeAbortingExoticSearchParams(workStore.route, prerenderStore);\n    }\n    // The remaining cases are prerender-ppr and prerender-legacy\n    // We are in a legacy static generation and need to interrupt the prerender\n    // when search params are accessed.\n    return makeErroringExoticSearchParams(workStore, prerenderStore);\n}\nfunction createRenderSearchParams(underlyingSearchParams, workStore) {\n    if (workStore.forceStatic) {\n        // When using forceStatic we override all other logic and always just return an empty\n        // dictionary object.\n        return Promise.resolve({});\n    } else {\n        if ( true && !workStore.isPrefetchRequest) {\n            return makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, workStore);\n        } else {\n            return makeUntrackedExoticSearchParams(underlyingSearchParams, workStore);\n        }\n    }\n}\nconst CachedSearchParams = new WeakMap();\nfunction makeAbortingExoticSearchParams(route, prerenderStore) {\n    const cachedSearchParams = CachedSearchParams.get(prerenderStore);\n    if (cachedSearchParams) {\n        return cachedSearchParams;\n    }\n    const promise = (0, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, '`searchParams`');\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            if (Object.hasOwn(promise, prop)) {\n                // The promise has this property directly. we must return it.\n                // We know it isn't a dynamic access because it can only be something\n                // that was previously written to the promise and thus not an underlying searchParam value\n                return _reflect.ReflectAdapter.get(target, prop, receiver);\n            }\n            switch(prop){\n                case 'then':\n                    {\n                        const expression = '`await searchParams`, `searchParams.then`, or similar';\n                        (0, _dynamicrendering.annotateDynamicAccess)(expression, prerenderStore);\n                        return _reflect.ReflectAdapter.get(target, prop, receiver);\n                    }\n                case 'status':\n                    {\n                        const expression = '`use(searchParams)`, `searchParams.status`, or similar';\n                        (0, _dynamicrendering.annotateDynamicAccess)(expression, prerenderStore);\n                        return _reflect.ReflectAdapter.get(target, prop, receiver);\n                    }\n                // Object prototype\n                case 'hasOwnProperty':\n                case 'isPrototypeOf':\n                case 'propertyIsEnumerable':\n                case 'toString':\n                case 'valueOf':\n                case 'toLocaleString':\n                // Promise prototype\n                // fallthrough\n                case 'catch':\n                case 'finally':\n                // Common tested properties\n                // fallthrough\n                case 'toJSON':\n                case '$$typeof':\n                case '__esModule':\n                    {\n                        // These properties cannot be shadowed because they need to be the\n                        // true underlying value for Promises to work correctly at runtime\n                        return _reflect.ReflectAdapter.get(target, prop, receiver);\n                    }\n                default:\n                    {\n                        if (typeof prop === 'string') {\n                            const expression = (0, _utils.describeStringPropertyAccess)('searchParams', prop);\n                            const error = createSearchAccessError(route, expression);\n                            (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(route, expression, error, prerenderStore);\n                        }\n                        return _reflect.ReflectAdapter.get(target, prop, receiver);\n                    }\n            }\n        },\n        has (target, prop) {\n            // We don't expect key checking to be used except for testing the existence of\n            // searchParams so we make all has tests trigger dynamic. this means that `promise.then`\n            // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n            // you are testing whether the searchParams has a 'then' property.\n            if (typeof prop === 'string') {\n                const expression = (0, _utils.describeHasCheckingStringProperty)('searchParams', prop);\n                const error = createSearchAccessError(route, expression);\n                (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(route, expression, error, prerenderStore);\n            }\n            return _reflect.ReflectAdapter.has(target, prop);\n        },\n        ownKeys () {\n            const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';\n            const error = createSearchAccessError(route, expression);\n            (0, _dynamicrendering.abortAndThrowOnSynchronousRequestDataAccess)(route, expression, error, prerenderStore);\n        }\n    });\n    CachedSearchParams.set(prerenderStore, proxiedPromise);\n    return proxiedPromise;\n}\nfunction makeErroringExoticSearchParams(workStore, prerenderStore) {\n    const cachedSearchParams = CachedSearchParams.get(workStore);\n    if (cachedSearchParams) {\n        return cachedSearchParams;\n    }\n    const underlyingSearchParams = {};\n    // For search params we don't construct a ReactPromise because we want to interrupt\n    // rendering on any property access that was not set from outside and so we only want\n    // to have properties like value and status if React sets them.\n    const promise = Promise.resolve(underlyingSearchParams);\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            if (Object.hasOwn(promise, prop)) {\n                // The promise has this property directly. we must return it.\n                // We know it isn't a dynamic access because it can only be something\n                // that was previously written to the promise and thus not an underlying searchParam value\n                return _reflect.ReflectAdapter.get(target, prop, receiver);\n            }\n            switch(prop){\n                // Object prototype\n                case 'hasOwnProperty':\n                case 'isPrototypeOf':\n                case 'propertyIsEnumerable':\n                case 'toString':\n                case 'valueOf':\n                case 'toLocaleString':\n                // Promise prototype\n                // fallthrough\n                case 'catch':\n                case 'finally':\n                // Common tested properties\n                // fallthrough\n                case 'toJSON':\n                case '$$typeof':\n                case '__esModule':\n                    {\n                        // These properties cannot be shadowed because they need to be the\n                        // true underlying value for Promises to work correctly at runtime\n                        return _reflect.ReflectAdapter.get(target, prop, receiver);\n                    }\n                case 'then':\n                    {\n                        const expression = '`await searchParams`, `searchParams.then`, or similar';\n                        if (workStore.dynamicShouldError) {\n                            (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);\n                        } else if (prerenderStore.type === 'prerender-ppr') {\n                            // PPR Prerender (no dynamicIO)\n                            (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n                        } else {\n                            // Legacy Prerender\n                            (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n                        }\n                        return;\n                    }\n                case 'status':\n                    {\n                        const expression = '`use(searchParams)`, `searchParams.status`, or similar';\n                        if (workStore.dynamicShouldError) {\n                            (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);\n                        } else if (prerenderStore.type === 'prerender-ppr') {\n                            // PPR Prerender (no dynamicIO)\n                            (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n                        } else {\n                            // Legacy Prerender\n                            (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n                        }\n                        return;\n                    }\n                default:\n                    {\n                        if (typeof prop === 'string') {\n                            const expression = (0, _utils.describeStringPropertyAccess)('searchParams', prop);\n                            if (workStore.dynamicShouldError) {\n                                (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);\n                            } else if (prerenderStore.type === 'prerender-ppr') {\n                                // PPR Prerender (no dynamicIO)\n                                (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n                            } else {\n                                // Legacy Prerender\n                                (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n                            }\n                        }\n                        return _reflect.ReflectAdapter.get(target, prop, receiver);\n                    }\n            }\n        },\n        has (target, prop) {\n            // We don't expect key checking to be used except for testing the existence of\n            // searchParams so we make all has tests trigger dynamic. this means that `promise.then`\n            // can resolve to the then function on the Promise prototype but 'then' in promise will assume\n            // you are testing whether the searchParams has a 'then' property.\n            if (typeof prop === 'string') {\n                const expression = (0, _utils.describeHasCheckingStringProperty)('searchParams', prop);\n                if (workStore.dynamicShouldError) {\n                    (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);\n                } else if (prerenderStore.type === 'prerender-ppr') {\n                    // PPR Prerender (no dynamicIO)\n                    (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n                } else {\n                    // Legacy Prerender\n                    (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n                }\n                return false;\n            }\n            return _reflect.ReflectAdapter.has(target, prop);\n        },\n        ownKeys () {\n            const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';\n            if (workStore.dynamicShouldError) {\n                (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(workStore.route, expression);\n            } else if (prerenderStore.type === 'prerender-ppr') {\n                // PPR Prerender (no dynamicIO)\n                (0, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);\n            } else {\n                // Legacy Prerender\n                (0, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);\n            }\n        }\n    });\n    CachedSearchParams.set(workStore, proxiedPromise);\n    return proxiedPromise;\n}\nfunction makeUntrackedExoticSearchParams(underlyingSearchParams, store) {\n    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\n    if (cachedSearchParams) {\n        return cachedSearchParams;\n    }\n    // We don't use makeResolvedReactPromise here because searchParams\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = Promise.resolve(underlyingSearchParams);\n    CachedSearchParams.set(underlyingSearchParams, promise);\n    Object.keys(underlyingSearchParams).forEach((prop)=>{\n        switch(prop){\n            // Object prototype\n            case 'hasOwnProperty':\n            case 'isPrototypeOf':\n            case 'propertyIsEnumerable':\n            case 'toString':\n            case 'valueOf':\n            case 'toLocaleString':\n            // Promise prototype\n            // fallthrough\n            case 'then':\n            case 'catch':\n            case 'finally':\n            // React Promise extension\n            // fallthrough\n            case 'status':\n            // Common tested properties\n            // fallthrough\n            case 'toJSON':\n            case '$$typeof':\n            case '__esModule':\n                {\n                    break;\n                }\n            default:\n                {\n                    Object.defineProperty(promise, prop, {\n                        get () {\n                            const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n                            (0, _dynamicrendering.trackDynamicDataInDynamicRender)(store, workUnitStore);\n                            return underlyingSearchParams[prop];\n                        },\n                        set (value) {\n                            Object.defineProperty(promise, prop, {\n                                value,\n                                writable: true,\n                                enumerable: true\n                            });\n                        },\n                        enumerable: true,\n                        configurable: true\n                    });\n                }\n        }\n    });\n    return promise;\n}\nfunction makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(underlyingSearchParams, store) {\n    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams);\n    if (cachedSearchParams) {\n        return cachedSearchParams;\n    }\n    const proxiedProperties = new Set();\n    const unproxiedProperties = [];\n    // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying\n    // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender\n    // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking\n    // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger\n    // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce\n    // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.\n    let promiseInitialized = false;\n    const proxiedUnderlying = new Proxy(underlyingSearchParams, {\n        get (target, prop, receiver) {\n            if (typeof prop === 'string' && promiseInitialized) {\n                if (store.dynamicShouldError) {\n                    const expression = (0, _utils.describeStringPropertyAccess)('searchParams', prop);\n                    (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);\n                }\n                const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n                (0, _dynamicrendering.trackDynamicDataInDynamicRender)(store, workUnitStore);\n            }\n            return _reflect.ReflectAdapter.get(target, prop, receiver);\n        },\n        has (target, prop) {\n            if (typeof prop === 'string') {\n                if (store.dynamicShouldError) {\n                    const expression = (0, _utils.describeHasCheckingStringProperty)('searchParams', prop);\n                    (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);\n                }\n            }\n            return Reflect.has(target, prop);\n        },\n        ownKeys (target) {\n            if (store.dynamicShouldError) {\n                const expression = '`{...searchParams}`, `Object.keys(searchParams)`, or similar';\n                (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);\n            }\n            return Reflect.ownKeys(target);\n        }\n    });\n    // We don't use makeResolvedReactPromise here because searchParams\n    // supports copying with spread and we don't want to unnecessarily\n    // instrument the promise with spreadable properties of ReactPromise.\n    const promise = new Promise((resolve)=>(0, _scheduler.scheduleImmediate)(()=>resolve(underlyingSearchParams)));\n    promise.then(()=>{\n        promiseInitialized = true;\n    });\n    Object.keys(underlyingSearchParams).forEach((prop)=>{\n        if (_utils.wellKnownProperties.has(prop)) {\n            // These properties cannot be shadowed because they need to be the\n            // true underlying value for Promises to work correctly at runtime\n            unproxiedProperties.push(prop);\n        } else {\n            proxiedProperties.add(prop);\n            Object.defineProperty(promise, prop, {\n                get () {\n                    return proxiedUnderlying[prop];\n                },\n                set (newValue) {\n                    Object.defineProperty(promise, prop, {\n                        value: newValue,\n                        writable: true,\n                        enumerable: true\n                    });\n                },\n                enumerable: true,\n                configurable: true\n            });\n        }\n    });\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            if (prop === 'then' && store.dynamicShouldError) {\n                const expression = '`searchParams.then`';\n                (0, _utils.throwWithStaticGenerationBailoutErrorWithDynamicError)(store.route, expression);\n            }\n            if (typeof prop === 'string') {\n                if (!_utils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor\n                // the underlying searchParams.\n                Reflect.has(target, prop) === false)) {\n                    const expression = (0, _utils.describeStringPropertyAccess)('searchParams', prop);\n                    syncIODev(store.route, expression);\n                }\n            }\n            return _reflect.ReflectAdapter.get(target, prop, receiver);\n        },\n        set (target, prop, value, receiver) {\n            if (typeof prop === 'string') {\n                proxiedProperties.delete(prop);\n            }\n            return Reflect.set(target, prop, value, receiver);\n        },\n        has (target, prop) {\n            if (typeof prop === 'string') {\n                if (!_utils.wellKnownProperties.has(prop) && (proxiedProperties.has(prop) || // We are accessing a property that doesn't exist on the promise nor\n                // the underlying searchParams.\n                Reflect.has(target, prop) === false)) {\n                    const expression = (0, _utils.describeHasCheckingStringProperty)('searchParams', prop);\n                    syncIODev(store.route, expression);\n                }\n            }\n            return Reflect.has(target, prop);\n        },\n        ownKeys (target) {\n            const expression = '`Object.keys(searchParams)` or similar';\n            syncIODev(store.route, expression, unproxiedProperties);\n            return Reflect.ownKeys(target);\n        }\n    });\n    CachedSearchParams.set(underlyingSearchParams, proxiedPromise);\n    return proxiedPromise;\n}\nfunction syncIODev(route, expression, missingProperties) {\n    // In all cases we warn normally\n    if (missingProperties && missingProperties.length > 0) {\n        warnForIncompleteEnumeration(route, expression, missingProperties);\n    } else {\n        warnForSyncAccess(route, expression);\n    }\n    const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();\n    if (workUnitStore && workUnitStore.type === 'request' && workUnitStore.prerenderPhase === true) {\n        // When we're rendering dynamically in dev we need to advance out of the\n        // Prerender environment when we read Request data synchronously\n        const requestStore = workUnitStore;\n        (0, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(requestStore);\n    }\n}\nconst noop = ()=>{};\nconst warnForSyncAccess =  false ? 0 : (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createSearchAccessError);\nconst warnForIncompleteEnumeration =  false ? 0 : (0, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createIncompleteEnumerationError);\nfunction createSearchAccessError(route, expression) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return new Error(`${prefix}used ${expression}. ` + `\\`searchParams\\` should be awaited before using its properties. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n}\nfunction createIncompleteEnumerationError(route, expression, missingProperties) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return new Error(`${prefix}used ${expression}. ` + `\\`searchParams\\` should be awaited before using its properties. ` + `The following properties were not available through enumeration ` + `because they conflict with builtin or well-known property names: ` + `${describeListOfPropertyNames(missingProperties)}. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`);\n}\nfunction describeListOfPropertyNames(properties) {\n    switch(properties.length){\n        case 0:\n            throw new _invarianterror.InvariantError('Expected describeListOfPropertyNames to be called with a non-empty list of strings.');\n        case 1:\n            return `\\`${properties[0]}\\``;\n        case 2:\n            return `\\`${properties[0]}\\` and \\`${properties[1]}\\``;\n        default:\n            {\n                let description = '';\n                for(let i = 0; i < properties.length - 1; i++){\n                    description += `\\`${properties[i]}\\`, `;\n                }\n                description += `, and \\`${properties[properties.length - 1]}\\``;\n                return description;\n            }\n    }\n}\n\n//# sourceMappingURL=search-params.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3Qvc2VhcmNoLXBhcmFtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLE1BQU0sQ0FLTDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCLG1CQUFPLENBQUMsMElBQXdDO0FBQ2pFLDBCQUEwQixtQkFBTyxDQUFDLDRIQUFpQztBQUNuRSxzQ0FBc0MsbUJBQU8sQ0FBQyxvSkFBZ0Q7QUFDOUYsd0JBQXdCLG1CQUFPLENBQUMsb0hBQWtDO0FBQ2xFLCtCQUErQixtQkFBTyxDQUFDLGtIQUE0QjtBQUNuRSxrREFBa0QsbUJBQU8sQ0FBQyxnS0FBbUQ7QUFDN0csZUFBZSxtQkFBTyxDQUFDLHFGQUFTO0FBQ2hDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxNQUFNO0FBQ04sWUFBWSxLQUFzQztBQUNsRDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBb0QsR0FBRyxDQUFJO0FBQ3JGLHFDQUFxQyxNQUFvRCxHQUFHLENBQUk7QUFDaEc7QUFDQSxxQ0FBcUMsTUFBTTtBQUMzQyx3QkFBd0IsT0FBTyxPQUFPLFdBQVc7QUFDakQ7QUFDQTtBQUNBLHFDQUFxQyxNQUFNO0FBQzNDLHdCQUF3QixPQUFPLE9BQU8sV0FBVyx5TkFBeU4sK0NBQStDO0FBQ3pUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0Esd0JBQXdCLGNBQWMsV0FBVyxjQUFjO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyQkFBMkI7QUFDMUQsd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQSwwQ0FBMEMsa0NBQWtDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEhvbWVcXERlc2t0b3BcXG54dHByb2plY3RcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcc2VydmVyXFxyZXF1ZXN0XFxzZWFyY2gtcGFyYW1zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY3JlYXRlUHJlcmVuZGVyU2VhcmNoUGFyYW1zRm9yQ2xpZW50UGFnZTogbnVsbCxcbiAgICBjcmVhdGVTZWFyY2hQYXJhbXNGcm9tQ2xpZW50OiBudWxsLFxuICAgIGNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0Zvck1ldGFkYXRhOiBudWxsLFxuICAgIGNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0ZvclNlcnZlclBhZ2U6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgY3JlYXRlUHJlcmVuZGVyU2VhcmNoUGFyYW1zRm9yQ2xpZW50UGFnZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQcmVyZW5kZXJTZWFyY2hQYXJhbXNGb3JDbGllbnRQYWdlO1xuICAgIH0sXG4gICAgY3JlYXRlU2VhcmNoUGFyYW1zRnJvbUNsaWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTZWFyY2hQYXJhbXNGcm9tQ2xpZW50O1xuICAgIH0sXG4gICAgY3JlYXRlU2VydmVyU2VhcmNoUGFyYW1zRm9yTWV0YWRhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2VydmVyU2VhcmNoUGFyYW1zRm9yTWV0YWRhdGE7XG4gICAgfSxcbiAgICBjcmVhdGVTZXJ2ZXJTZWFyY2hQYXJhbXNGb3JTZXJ2ZXJQYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0ZvclNlcnZlclBhZ2U7XG4gICAgfVxufSk7XG5jb25zdCBfcmVmbGVjdCA9IHJlcXVpcmUoXCIuLi93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvcmVmbGVjdFwiKTtcbmNvbnN0IF9keW5hbWljcmVuZGVyaW5nID0gcmVxdWlyZShcIi4uL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmdcIik7XG5jb25zdCBfd29ya3VuaXRhc3luY3N0b3JhZ2VleHRlcm5hbCA9IHJlcXVpcmUoXCIuLi9hcHAtcmVuZGVyL3dvcmstdW5pdC1hc3luYy1zdG9yYWdlLmV4dGVybmFsXCIpO1xuY29uc3QgX2ludmFyaWFudGVycm9yID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvaW52YXJpYW50LWVycm9yXCIpO1xuY29uc3QgX2R5bmFtaWNyZW5kZXJpbmd1dGlscyA9IHJlcXVpcmUoXCIuLi9keW5hbWljLXJlbmRlcmluZy11dGlsc1wiKTtcbmNvbnN0IF9jcmVhdGVkZWR1cGVkYnljYWxsc2l0ZXNlcnZlcmVycm9ybG9nZ2VyID0gcmVxdWlyZShcIi4uL2NyZWF0ZS1kZWR1cGVkLWJ5LWNhbGxzaXRlLXNlcnZlci1lcnJvci1sb2dnZXJcIik7XG5jb25zdCBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IF9zY2hlZHVsZXIgPSByZXF1aXJlKFwiLi4vLi4vbGliL3NjaGVkdWxlclwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaFBhcmFtc0Zyb21DbGllbnQodW5kZXJseWluZ1NlYXJjaFBhcmFtcywgd29ya1N0b3JlKSB7XG4gICAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsLndvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgICAgc3dpdGNoKHdvcmtVbml0U3RvcmUudHlwZSl7XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgICAgICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJlcmVuZGVyU2VhcmNoUGFyYW1zKHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXModW5kZXJseWluZ1NlYXJjaFBhcmFtcywgd29ya1N0b3JlKTtcbn1cbmNvbnN0IGNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0Zvck1ldGFkYXRhID0gY3JlYXRlU2VydmVyU2VhcmNoUGFyYW1zRm9yU2VydmVyUGFnZTtcbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlclNlYXJjaFBhcmFtc0ZvclNlcnZlclBhZ2UodW5kZXJseWluZ1NlYXJjaFBhcmFtcywgd29ya1N0b3JlKSB7XG4gICAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsLndvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgICAgc3dpdGNoKHdvcmtVbml0U3RvcmUudHlwZSl7XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgICAgICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgICAgICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJlcmVuZGVyU2VhcmNoUGFyYW1zKHdvcmtTdG9yZSwgd29ya1VuaXRTdG9yZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXModW5kZXJseWluZ1NlYXJjaFBhcmFtcywgd29ya1N0b3JlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByZXJlbmRlclNlYXJjaFBhcmFtc0ZvckNsaWVudFBhZ2Uod29ya1N0b3JlKSB7XG4gICAgaWYgKHdvcmtTdG9yZS5mb3JjZVN0YXRpYykge1xuICAgICAgICAvLyBXaGVuIHVzaW5nIGZvcmNlU3RhdGljIHdlIG92ZXJyaWRlIGFsbCBvdGhlciBsb2dpYyBhbmQgYWx3YXlzIGp1c3QgcmV0dXJuIGFuIGVtcHR5XG4gICAgICAgIC8vIGRpY3Rpb25hcnkgb2JqZWN0LlxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICB9XG4gICAgY29uc3QgcHJlcmVuZGVyU3RvcmUgPSBfd29ya3VuaXRhc3luY3N0b3JhZ2VleHRlcm5hbC53b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGlmIChwcmVyZW5kZXJTdG9yZSAmJiBwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyJykge1xuICAgICAgICAvLyBkeW5hbWljSU8gUHJlcmVuZGVyXG4gICAgICAgIC8vIFdlJ3JlIHByZXJlbmRlcmluZyBpbiBhIG1vZGUgdGhhdCBhYm9ydHMgKGR5bmFtaWNJTykgYW5kIHNob3VsZCBzdGFsbFxuICAgICAgICAvLyB0aGUgcHJvbWlzZSB0byBlbnN1cmUgdGhlIFJTQyBzaWRlIGlzIGNvbnNpZGVyZWQgZHluYW1pY1xuICAgICAgICByZXR1cm4gKDAsIF9keW5hbWljcmVuZGVyaW5ndXRpbHMubWFrZUhhbmdpbmdQcm9taXNlKShwcmVyZW5kZXJTdG9yZS5yZW5kZXJTaWduYWwsICdgc2VhcmNoUGFyYW1zYCcpO1xuICAgIH1cbiAgICAvLyBXZSdyZSBwcmVyZW5kZXJpbmcgaW4gYSBtb2RlIHRoYXQgZG9lcyBub3QgYWJvcnRzLiBXZSByZXNvbHZlIHRoZSBwcm9taXNlIHdpdGhvdXRcbiAgICAvLyBhbnkgdHJhY2tpbmcgYmVjYXVzZSB3ZSdyZSBqdXN0IHRyYW5zcG9ydGluZyBhIHZhbHVlIGZyb20gc2VydmVyIHRvIGNsaWVudCB3aGVyZSB0aGUgdHJhY2tpbmdcbiAgICAvLyB3aWxsIGJlIGFwcGxpZWQuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQcmVyZW5kZXJTZWFyY2hQYXJhbXMod29ya1N0b3JlLCBwcmVyZW5kZXJTdG9yZSkge1xuICAgIGlmICh3b3JrU3RvcmUuZm9yY2VTdGF0aWMpIHtcbiAgICAgICAgLy8gV2hlbiB1c2luZyBmb3JjZVN0YXRpYyB3ZSBvdmVycmlkZSBhbGwgb3RoZXIgbG9naWMgYW5kIGFsd2F5cyBqdXN0IHJldHVybiBhbiBlbXB0eVxuICAgICAgICAvLyBkaWN0aW9uYXJ5IG9iamVjdC5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gICAgfVxuICAgIGlmIChwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyJykge1xuICAgICAgICAvLyBXZSBhcmUgaW4gYSBkeW5hbWljSU8gKFBQUiBvciBvdGhlcndpc2UpIHByZXJlbmRlclxuICAgICAgICByZXR1cm4gbWFrZUFib3J0aW5nRXhvdGljU2VhcmNoUGFyYW1zKHdvcmtTdG9yZS5yb3V0ZSwgcHJlcmVuZGVyU3RvcmUpO1xuICAgIH1cbiAgICAvLyBUaGUgcmVtYWluaW5nIGNhc2VzIGFyZSBwcmVyZW5kZXItcHByIGFuZCBwcmVyZW5kZXItbGVnYWN5XG4gICAgLy8gV2UgYXJlIGluIGEgbGVnYWN5IHN0YXRpYyBnZW5lcmF0aW9uIGFuZCBuZWVkIHRvIGludGVycnVwdCB0aGUgcHJlcmVuZGVyXG4gICAgLy8gd2hlbiBzZWFyY2ggcGFyYW1zIGFyZSBhY2Nlc3NlZC5cbiAgICByZXR1cm4gbWFrZUVycm9yaW5nRXhvdGljU2VhcmNoUGFyYW1zKHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyU2VhcmNoUGFyYW1zKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsIHdvcmtTdG9yZSkge1xuICAgIGlmICh3b3JrU3RvcmUuZm9yY2VTdGF0aWMpIHtcbiAgICAgICAgLy8gV2hlbiB1c2luZyBmb3JjZVN0YXRpYyB3ZSBvdmVycmlkZSBhbGwgb3RoZXIgbG9naWMgYW5kIGFsd2F5cyBqdXN0IHJldHVybiBhbiBlbXB0eVxuICAgICAgICAvLyBkaWN0aW9uYXJ5IG9iamVjdC5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICF3b3JrU3RvcmUuaXNQcmVmZXRjaFJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlRHluYW1pY2FsbHlUcmFja2VkRXhvdGljU2VhcmNoUGFyYW1zV2l0aERldldhcm5pbmdzKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMsIHdvcmtTdG9yZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZVVudHJhY2tlZEV4b3RpY1NlYXJjaFBhcmFtcyh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLCB3b3JrU3RvcmUpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgQ2FjaGVkU2VhcmNoUGFyYW1zID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIG1ha2VBYm9ydGluZ0V4b3RpY1NlYXJjaFBhcmFtcyhyb3V0ZSwgcHJlcmVuZGVyU3RvcmUpIHtcbiAgICBjb25zdCBjYWNoZWRTZWFyY2hQYXJhbXMgPSBDYWNoZWRTZWFyY2hQYXJhbXMuZ2V0KHByZXJlbmRlclN0b3JlKTtcbiAgICBpZiAoY2FjaGVkU2VhcmNoUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRTZWFyY2hQYXJhbXM7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSAoMCwgX2R5bmFtaWNyZW5kZXJpbmd1dGlscy5tYWtlSGFuZ2luZ1Byb21pc2UpKHByZXJlbmRlclN0b3JlLnJlbmRlclNpZ25hbCwgJ2BzZWFyY2hQYXJhbXNgJyk7XG4gICAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgICAgICBnZXQgKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKHByb21pc2UsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHByb21pc2UgaGFzIHRoaXMgcHJvcGVydHkgZGlyZWN0bHkuIHdlIG11c3QgcmV0dXJuIGl0LlxuICAgICAgICAgICAgICAgIC8vIFdlIGtub3cgaXQgaXNuJ3QgYSBkeW5hbWljIGFjY2VzcyBiZWNhdXNlIGl0IGNhbiBvbmx5IGJlIHNvbWV0aGluZ1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2FzIHByZXZpb3VzbHkgd3JpdHRlbiB0byB0aGUgcHJvbWlzZSBhbmQgdGh1cyBub3QgYW4gdW5kZXJseWluZyBzZWFyY2hQYXJhbSB2YWx1ZVxuICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2gocHJvcCl7XG4gICAgICAgICAgICAgICAgY2FzZSAndGhlbic6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYGF3YWl0IHNlYXJjaFBhcmFtc2AsIGBzZWFyY2hQYXJhbXMudGhlbmAsIG9yIHNpbWlsYXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLmFubm90YXRlRHluYW1pY0FjY2VzcykoZXhwcmVzc2lvbiwgcHJlcmVuZGVyU3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YXR1cyc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYHVzZShzZWFyY2hQYXJhbXMpYCwgYHNlYXJjaFBhcmFtcy5zdGF0dXNgLCBvciBzaW1pbGFyJztcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5hbm5vdGF0ZUR5bmFtaWNBY2Nlc3MpKGV4cHJlc3Npb24sIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPYmplY3QgcHJvdG90eXBlXG4gICAgICAgICAgICAgICAgY2FzZSAnaGFzT3duUHJvcGVydHknOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2lzUHJvdG90eXBlT2YnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJzpcbiAgICAgICAgICAgICAgICBjYXNlICd0b1N0cmluZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAndmFsdWVPZic6XG4gICAgICAgICAgICAgICAgY2FzZSAndG9Mb2NhbGVTdHJpbmcnOlxuICAgICAgICAgICAgICAgIC8vIFByb21pc2UgcHJvdG90eXBlXG4gICAgICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlICdjYXRjaCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZmluYWxseSc6XG4gICAgICAgICAgICAgICAgLy8gQ29tbW9uIHRlc3RlZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlICd0b0pTT04nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyQkdHlwZW9mJzpcbiAgICAgICAgICAgICAgICBjYXNlICdfX2VzTW9kdWxlJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBjYW5ub3QgYmUgc2hhZG93ZWQgYmVjYXVzZSB0aGV5IG5lZWQgdG8gYmUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIHVuZGVybHlpbmcgdmFsdWUgZm9yIFByb21pc2VzIHRvIHdvcmsgY29ycmVjdGx5IGF0IHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuZGVzY3JpYmVTdHJpbmdQcm9wZXJ0eUFjY2VzcykoJ3NlYXJjaFBhcmFtcycsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY3JlYXRlU2VhcmNoQWNjZXNzRXJyb3Iocm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5hYm9ydEFuZFRocm93T25TeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzKShyb3V0ZSwgZXhwcmVzc2lvbiwgZXJyb3IsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaGFzICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGV4cGVjdCBrZXkgY2hlY2tpbmcgdG8gYmUgdXNlZCBleGNlcHQgZm9yIHRlc3RpbmcgdGhlIGV4aXN0ZW5jZSBvZlxuICAgICAgICAgICAgLy8gc2VhcmNoUGFyYW1zIHNvIHdlIG1ha2UgYWxsIGhhcyB0ZXN0cyB0cmlnZ2VyIGR5bmFtaWMuIHRoaXMgbWVhbnMgdGhhdCBgcHJvbWlzZS50aGVuYFxuICAgICAgICAgICAgLy8gY2FuIHJlc29sdmUgdG8gdGhlIHRoZW4gZnVuY3Rpb24gb24gdGhlIFByb21pc2UgcHJvdG90eXBlIGJ1dCAndGhlbicgaW4gcHJvbWlzZSB3aWxsIGFzc3VtZVxuICAgICAgICAgICAgLy8geW91IGFyZSB0ZXN0aW5nIHdoZXRoZXIgdGhlIHNlYXJjaFBhcmFtcyBoYXMgYSAndGhlbicgcHJvcGVydHkuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5KSgnc2VhcmNoUGFyYW1zJywgcHJvcCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBjcmVhdGVTZWFyY2hBY2Nlc3NFcnJvcihyb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLmFib3J0QW5kVGhyb3dPblN5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3MpKHJvdXRlLCBleHByZXNzaW9uLCBlcnJvciwgcHJlcmVuZGVyU3RvcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgICB9LFxuICAgICAgICBvd25LZXlzICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYHsuLi5zZWFyY2hQYXJhbXN9YCwgYE9iamVjdC5rZXlzKHNlYXJjaFBhcmFtcylgLCBvciBzaW1pbGFyJztcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY3JlYXRlU2VhcmNoQWNjZXNzRXJyb3Iocm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLmFib3J0QW5kVGhyb3dPblN5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3MpKHJvdXRlLCBleHByZXNzaW9uLCBlcnJvciwgcHJlcmVuZGVyU3RvcmUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgQ2FjaGVkU2VhcmNoUGFyYW1zLnNldChwcmVyZW5kZXJTdG9yZSwgcHJveGllZFByb21pc2UpO1xuICAgIHJldHVybiBwcm94aWVkUHJvbWlzZTtcbn1cbmZ1bmN0aW9uIG1ha2VFcnJvcmluZ0V4b3RpY1NlYXJjaFBhcmFtcyh3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKSB7XG4gICAgY29uc3QgY2FjaGVkU2VhcmNoUGFyYW1zID0gQ2FjaGVkU2VhcmNoUGFyYW1zLmdldCh3b3JrU3RvcmUpO1xuICAgIGlmIChjYWNoZWRTZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNlYXJjaFBhcmFtcztcbiAgICB9XG4gICAgY29uc3QgdW5kZXJseWluZ1NlYXJjaFBhcmFtcyA9IHt9O1xuICAgIC8vIEZvciBzZWFyY2ggcGFyYW1zIHdlIGRvbid0IGNvbnN0cnVjdCBhIFJlYWN0UHJvbWlzZSBiZWNhdXNlIHdlIHdhbnQgdG8gaW50ZXJydXB0XG4gICAgLy8gcmVuZGVyaW5nIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCB3YXMgbm90IHNldCBmcm9tIG91dHNpZGUgYW5kIHNvIHdlIG9ubHkgd2FudFxuICAgIC8vIHRvIGhhdmUgcHJvcGVydGllcyBsaWtlIHZhbHVlIGFuZCBzdGF0dXMgaWYgUmVhY3Qgc2V0cyB0aGVtLlxuICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZXJseWluZ1NlYXJjaFBhcmFtcyk7XG4gICAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgICAgICBnZXQgKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duKHByb21pc2UsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHByb21pc2UgaGFzIHRoaXMgcHJvcGVydHkgZGlyZWN0bHkuIHdlIG11c3QgcmV0dXJuIGl0LlxuICAgICAgICAgICAgICAgIC8vIFdlIGtub3cgaXQgaXNuJ3QgYSBkeW5hbWljIGFjY2VzcyBiZWNhdXNlIGl0IGNhbiBvbmx5IGJlIHNvbWV0aGluZ1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2FzIHByZXZpb3VzbHkgd3JpdHRlbiB0byB0aGUgcHJvbWlzZSBhbmQgdGh1cyBub3QgYW4gdW5kZXJseWluZyBzZWFyY2hQYXJhbSB2YWx1ZVxuICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2gocHJvcCl7XG4gICAgICAgICAgICAgICAgLy8gT2JqZWN0IHByb3RvdHlwZVxuICAgICAgICAgICAgICAgIGNhc2UgJ2hhc093blByb3BlcnR5JzpcbiAgICAgICAgICAgICAgICBjYXNlICdpc1Byb3RvdHlwZU9mJzpcbiAgICAgICAgICAgICAgICBjYXNlICdwcm9wZXJ0eUlzRW51bWVyYWJsZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndG9TdHJpbmcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlT2YnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RvTG9jYWxlU3RyaW5nJzpcbiAgICAgICAgICAgICAgICAvLyBQcm9taXNlIHByb3RvdHlwZVxuICAgICAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgY2FzZSAnY2F0Y2gnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbmFsbHknOlxuICAgICAgICAgICAgICAgIC8vIENvbW1vbiB0ZXN0ZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgY2FzZSAndG9KU09OJzpcbiAgICAgICAgICAgICAgICBjYXNlICckJHR5cGVvZic6XG4gICAgICAgICAgICAgICAgY2FzZSAnX19lc01vZHVsZSc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY2Fubm90IGJlIHNoYWRvd2VkIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSB1bmRlcmx5aW5nIHZhbHVlIGZvciBQcm9taXNlcyB0byB3b3JrIGNvcnJlY3RseSBhdCBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZmxlY3QuUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAndGhlbic6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYGF3YWl0IHNlYXJjaFBhcmFtc2AsIGBzZWFyY2hQYXJhbXMudGhlbmAsIG9yIHNpbWlsYXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtTdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWxzLnRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yKSh3b3JrU3RvcmUucm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLXBwcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQUFIgUHJlcmVuZGVyIChubyBkeW5hbWljSU8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnBvc3Rwb25lV2l0aFRyYWNraW5nKSh3b3JrU3RvcmUucm91dGUsIGV4cHJlc3Npb24sIHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBQcmVyZW5kZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24pKGV4cHJlc3Npb24sIHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhdHVzJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgdXNlKHNlYXJjaFBhcmFtcylgLCBgc2VhcmNoUGFyYW1zLnN0YXR1c2AsIG9yIHNpbWlsYXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtTdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWxzLnRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yKSh3b3JrU3RvcmUucm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmVyZW5kZXJTdG9yZS50eXBlID09PSAncHJlcmVuZGVyLXBwcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQUFIgUHJlcmVuZGVyIChubyBkeW5hbWljSU8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnBvc3Rwb25lV2l0aFRyYWNraW5nKSh3b3JrU3RvcmUucm91dGUsIGV4cHJlc3Npb24sIHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBQcmVyZW5kZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24pKGV4cHJlc3Npb24sIHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MpKCdzZWFyY2hQYXJhbXMnLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya1N0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWxzLnRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yKSh3b3JrU3RvcmUucm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBQUiBQcmVyZW5kZXIgKG5vIGR5bmFtaWNJTylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnBvc3Rwb25lV2l0aFRyYWNraW5nKSh3b3JrU3RvcmUucm91dGUsIGV4cHJlc3Npb24sIHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVnYWN5IFByZXJlbmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24pKGV4cHJlc3Npb24sIHdvcmtTdG9yZSwgcHJlcmVuZGVyU3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmbGVjdC5SZWZsZWN0QWRhcHRlci5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaGFzICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGV4cGVjdCBrZXkgY2hlY2tpbmcgdG8gYmUgdXNlZCBleGNlcHQgZm9yIHRlc3RpbmcgdGhlIGV4aXN0ZW5jZSBvZlxuICAgICAgICAgICAgLy8gc2VhcmNoUGFyYW1zIHNvIHdlIG1ha2UgYWxsIGhhcyB0ZXN0cyB0cmlnZ2VyIGR5bmFtaWMuIHRoaXMgbWVhbnMgdGhhdCBgcHJvbWlzZS50aGVuYFxuICAgICAgICAgICAgLy8gY2FuIHJlc29sdmUgdG8gdGhlIHRoZW4gZnVuY3Rpb24gb24gdGhlIFByb21pc2UgcHJvdG90eXBlIGJ1dCAndGhlbicgaW4gcHJvbWlzZSB3aWxsIGFzc3VtZVxuICAgICAgICAgICAgLy8geW91IGFyZSB0ZXN0aW5nIHdoZXRoZXIgdGhlIHNlYXJjaFBhcmFtcyBoYXMgYSAndGhlbicgcHJvcGVydHkuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5KSgnc2VhcmNoUGFyYW1zJywgcHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtTdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlscy50aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcikod29ya1N0b3JlLnJvdXRlLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXJlbmRlclN0b3JlLnR5cGUgPT09ICdwcmVyZW5kZXItcHByJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBQUFIgUHJlcmVuZGVyIChubyBkeW5hbWljSU8pXG4gICAgICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5wb3N0cG9uZVdpdGhUcmFja2luZykod29ya1N0b3JlLnJvdXRlLCBleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBQcmVyZW5kZXJcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKShleHByZXNzaW9uLCB3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgICB9LFxuICAgICAgICBvd25LZXlzICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYHsuLi5zZWFyY2hQYXJhbXN9YCwgYE9iamVjdC5rZXlzKHNlYXJjaFBhcmFtcylgLCBvciBzaW1pbGFyJztcbiAgICAgICAgICAgIGlmICh3b3JrU3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlscy50aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcikod29ya1N0b3JlLnJvdXRlLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInKSB7XG4gICAgICAgICAgICAgICAgLy8gUFBSIFByZXJlbmRlciAobm8gZHluYW1pY0lPKVxuICAgICAgICAgICAgICAgICgwLCBfZHluYW1pY3JlbmRlcmluZy5wb3N0cG9uZVdpdGhUcmFja2luZykod29ya1N0b3JlLnJvdXRlLCBleHByZXNzaW9uLCBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMZWdhY3kgUHJlcmVuZGVyXG4gICAgICAgICAgICAgICAgKDAsIF9keW5hbWljcmVuZGVyaW5nLnRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uKShleHByZXNzaW9uLCB3b3JrU3RvcmUsIHByZXJlbmRlclN0b3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIENhY2hlZFNlYXJjaFBhcmFtcy5zZXQod29ya1N0b3JlLCBwcm94aWVkUHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb3hpZWRQcm9taXNlO1xufVxuZnVuY3Rpb24gbWFrZVVudHJhY2tlZEV4b3RpY1NlYXJjaFBhcmFtcyh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLCBzdG9yZSkge1xuICAgIGNvbnN0IGNhY2hlZFNlYXJjaFBhcmFtcyA9IENhY2hlZFNlYXJjaFBhcmFtcy5nZXQodW5kZXJseWluZ1NlYXJjaFBhcmFtcyk7XG4gICAgaWYgKGNhY2hlZFNlYXJjaFBhcmFtcykge1xuICAgICAgICByZXR1cm4gY2FjaGVkU2VhcmNoUGFyYW1zO1xuICAgIH1cbiAgICAvLyBXZSBkb24ndCB1c2UgbWFrZVJlc29sdmVkUmVhY3RQcm9taXNlIGhlcmUgYmVjYXVzZSBzZWFyY2hQYXJhbXNcbiAgICAvLyBzdXBwb3J0cyBjb3B5aW5nIHdpdGggc3ByZWFkIGFuZCB3ZSBkb24ndCB3YW50IHRvIHVubmVjZXNzYXJpbHlcbiAgICAvLyBpbnN0cnVtZW50IHRoZSBwcm9taXNlIHdpdGggc3ByZWFkYWJsZSBwcm9wZXJ0aWVzIG9mIFJlYWN0UHJvbWlzZS5cbiAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVybHlpbmdTZWFyY2hQYXJhbXMpO1xuICAgIENhY2hlZFNlYXJjaFBhcmFtcy5zZXQodW5kZXJseWluZ1NlYXJjaFBhcmFtcywgcHJvbWlzZSk7XG4gICAgT2JqZWN0LmtleXModW5kZXJseWluZ1NlYXJjaFBhcmFtcykuZm9yRWFjaCgocHJvcCk9PntcbiAgICAgICAgc3dpdGNoKHByb3Ape1xuICAgICAgICAgICAgLy8gT2JqZWN0IHByb3RvdHlwZVxuICAgICAgICAgICAgY2FzZSAnaGFzT3duUHJvcGVydHknOlxuICAgICAgICAgICAgY2FzZSAnaXNQcm90b3R5cGVPZic6XG4gICAgICAgICAgICBjYXNlICdwcm9wZXJ0eUlzRW51bWVyYWJsZSc6XG4gICAgICAgICAgICBjYXNlICd0b1N0cmluZyc6XG4gICAgICAgICAgICBjYXNlICd2YWx1ZU9mJzpcbiAgICAgICAgICAgIGNhc2UgJ3RvTG9jYWxlU3RyaW5nJzpcbiAgICAgICAgICAgIC8vIFByb21pc2UgcHJvdG90eXBlXG4gICAgICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAndGhlbic6XG4gICAgICAgICAgICBjYXNlICdjYXRjaCc6XG4gICAgICAgICAgICBjYXNlICdmaW5hbGx5JzpcbiAgICAgICAgICAgIC8vIFJlYWN0IFByb21pc2UgZXh0ZW5zaW9uXG4gICAgICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAnc3RhdHVzJzpcbiAgICAgICAgICAgIC8vIENvbW1vbiB0ZXN0ZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ3RvSlNPTic6XG4gICAgICAgICAgICBjYXNlICckJHR5cGVvZic6XG4gICAgICAgICAgICBjYXNlICdfX2VzTW9kdWxlJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgcHJvcCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0ICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3b3JrVW5pdFN0b3JlID0gX3dvcmt1bml0YXN5bmNzdG9yYWdlZXh0ZXJuYWwud29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlcikoc3RvcmUsIHdvcmtVbml0U3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlcmx5aW5nU2VhcmNoUGFyYW1zW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgcHJvcCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gbWFrZUR5bmFtaWNhbGx5VHJhY2tlZEV4b3RpY1NlYXJjaFBhcmFtc1dpdGhEZXZXYXJuaW5ncyh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLCBzdG9yZSkge1xuICAgIGNvbnN0IGNhY2hlZFNlYXJjaFBhcmFtcyA9IENhY2hlZFNlYXJjaFBhcmFtcy5nZXQodW5kZXJseWluZ1NlYXJjaFBhcmFtcyk7XG4gICAgaWYgKGNhY2hlZFNlYXJjaFBhcmFtcykge1xuICAgICAgICByZXR1cm4gY2FjaGVkU2VhcmNoUGFyYW1zO1xuICAgIH1cbiAgICBjb25zdCBwcm94aWVkUHJvcGVydGllcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1bnByb3hpZWRQcm9wZXJ0aWVzID0gW107XG4gICAgLy8gV2UgaGF2ZSBhbiB1bmZvcnR1bmF0ZSBzZXF1ZW5jZSBvZiBldmVudHMgdGhhdCByZXF1aXJlcyB0aGlzIGluaXRpYWxpemF0aW9uIGxvZ2ljLiBXZSB3YW50IHRvIGluc3RydW1lbnQgdGhlIHVuZGVybHlpbmdcbiAgICAvLyBzZWFyY2hQYXJhbXMgb2JqZWN0IHRvIGRldGVjdCBpZiB5b3UgYXJlIGFjY2Vzc2luZyB2YWx1ZXMgaW4gZGV2LiBUaGlzIGlzIHVzZWQgZm9yIHdhcm5pbmdzIGFuZCBmb3IgdGhpbmdzIGxpa2UgdGhlIHN0YXRpYyBwcmVyZW5kZXJcbiAgICAvLyBpbmRpY2F0b3IuIEhvd2V2ZXIgd2hlbiB3ZSBwYXNzIHRoaXMgcHJveHkgdG8gb3VyIFByb21pc2UucmVzb2x2ZSgpIGJlbG93IHRoZSBWTSBjaGVja3MgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGEgcHJvbWlzZSBieSBsb29raW5nXG4gICAgLy8gYXQgdGhlIGAudGhlbmAgcHJvcGVydHkuIFRvIG91ciBkeW5hbWljIHRyYWNraW5nIGxvZ2ljIHRoaXMgaXMgaW5kaXN0aW5ndWlzaGFibGUgZnJvbSBhIGB0aGVuYCBzZWFyY2hQYXJhbSBhbmQgc28gd2Ugd291bGQgbm9ybWFsbHkgdHJpZ2dlclxuICAgIC8vIGR5bmFtaWMgdHJhY2tpbmcuIEhvd2V2ZXIgd2Uga25vdyB0aGF0IHRoaXMgLnRoZW4gaXMgbm90IHJlYWwgZHluYW1pYyBhY2Nlc3MsIGl0J3MganVzdCBob3cgdGhlbmFibGVzIHJlc29sdmUgaW4gc2VxdWVuY2UuIFNvIHdlIGludHJvZHVjZVxuICAgIC8vIHRoaXMgaW5pdGlhbGl6YXRpb24gY29uY2VwdCBzbyB3ZSBvbWl0IHRoZSBkeW5hbWljIGNoZWNrIHVudGlsIGFmdGVyIHdlJ3ZlIGNvbnN0cnVjdGVkIG91ciByZXNvbHZlZCBwcm9taXNlLlxuICAgIGxldCBwcm9taXNlSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBwcm94aWVkVW5kZXJseWluZyA9IG5ldyBQcm94eSh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLCB7XG4gICAgICAgIGdldCAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJyAmJiBwcm9taXNlSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmRlc2NyaWJlU3RyaW5nUHJvcGVydHlBY2Nlc3MpKCdzZWFyY2hQYXJhbXMnLCBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlscy50aHJvd1dpdGhTdGF0aWNHZW5lcmF0aW9uQmFpbG91dEVycm9yV2l0aER5bmFtaWNFcnJvcikoc3RvcmUucm91dGUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB3b3JrVW5pdFN0b3JlID0gX3dvcmt1bml0YXN5bmNzdG9yYWdlZXh0ZXJuYWwud29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlcikoc3RvcmUsIHdvcmtVbml0U3RvcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmRlc2NyaWJlSGFzQ2hlY2tpbmdTdHJpbmdQcm9wZXJ0eSkoJ3NlYXJjaFBhcmFtcycsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWxzLnRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yKShzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIG93bktleXMgKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHN0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYHsuLi5zZWFyY2hQYXJhbXN9YCwgYE9iamVjdC5rZXlzKHNlYXJjaFBhcmFtcylgLCBvciBzaW1pbGFyJztcbiAgICAgICAgICAgICAgICAoMCwgX3V0aWxzLnRocm93V2l0aFN0YXRpY0dlbmVyYXRpb25CYWlsb3V0RXJyb3JXaXRoRHluYW1pY0Vycm9yKShzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBXZSBkb24ndCB1c2UgbWFrZVJlc29sdmVkUmVhY3RQcm9taXNlIGhlcmUgYmVjYXVzZSBzZWFyY2hQYXJhbXNcbiAgICAvLyBzdXBwb3J0cyBjb3B5aW5nIHdpdGggc3ByZWFkIGFuZCB3ZSBkb24ndCB3YW50IHRvIHVubmVjZXNzYXJpbHlcbiAgICAvLyBpbnN0cnVtZW50IHRoZSBwcm9taXNlIHdpdGggc3ByZWFkYWJsZSBwcm9wZXJ0aWVzIG9mIFJlYWN0UHJvbWlzZS5cbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT4oMCwgX3NjaGVkdWxlci5zY2hlZHVsZUltbWVkaWF0ZSkoKCk9PnJlc29sdmUodW5kZXJseWluZ1NlYXJjaFBhcmFtcykpKTtcbiAgICBwcm9taXNlLnRoZW4oKCk9PntcbiAgICAgICAgcHJvbWlzZUluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBPYmplY3Qua2V5cyh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zKS5mb3JFYWNoKChwcm9wKT0+e1xuICAgICAgICBpZiAoX3V0aWxzLndlbGxLbm93blByb3BlcnRpZXMuaGFzKHByb3ApKSB7XG4gICAgICAgICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBzaGFkb3dlZCBiZWNhdXNlIHRoZXkgbmVlZCB0byBiZSB0aGVcbiAgICAgICAgICAgIC8vIHRydWUgdW5kZXJseWluZyB2YWx1ZSBmb3IgUHJvbWlzZXMgdG8gd29yayBjb3JyZWN0bHkgYXQgcnVudGltZVxuICAgICAgICAgICAgdW5wcm94aWVkUHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJveGllZFByb3BlcnRpZXMuYWRkKHByb3ApO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIHByb3AsIHtcbiAgICAgICAgICAgICAgICBnZXQgKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveGllZFVuZGVybHlpbmdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQgKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBwcm9wLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBwcm94aWVkUHJvbWlzZSA9IG5ldyBQcm94eShwcm9taXNlLCB7XG4gICAgICAgIGdldCAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHByb3AgPT09ICd0aGVuJyAmJiBzdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2BzZWFyY2hQYXJhbXMudGhlbmAnO1xuICAgICAgICAgICAgICAgICgwLCBfdXRpbHMudGhyb3dXaXRoU3RhdGljR2VuZXJhdGlvbkJhaWxvdXRFcnJvcldpdGhEeW5hbWljRXJyb3IpKHN0b3JlLnJvdXRlLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV91dGlscy53ZWxsS25vd25Qcm9wZXJ0aWVzLmhhcyhwcm9wKSAmJiAocHJveGllZFByb3BlcnRpZXMuaGFzKHByb3ApIHx8IC8vIFdlIGFyZSBhY2Nlc3NpbmcgYSBwcm9wZXJ0eSB0aGF0IGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHByb21pc2Ugbm9yXG4gICAgICAgICAgICAgICAgLy8gdGhlIHVuZGVybHlpbmcgc2VhcmNoUGFyYW1zLlxuICAgICAgICAgICAgICAgIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCkgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gKDAsIF91dGlscy5kZXNjcmliZVN0cmluZ1Byb3BlcnR5QWNjZXNzKSgnc2VhcmNoUGFyYW1zJywgcHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIHN5bmNJT0RldihzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZWZsZWN0LlJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0ICh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHByb3hpZWRQcm9wZXJ0aWVzLmRlbGV0ZShwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGhhcyAodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdXRpbHMud2VsbEtub3duUHJvcGVydGllcy5oYXMocHJvcCkgJiYgKHByb3hpZWRQcm9wZXJ0aWVzLmhhcyhwcm9wKSB8fCAvLyBXZSBhcmUgYWNjZXNzaW5nIGEgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGV4aXN0IG9uIHRoZSBwcm9taXNlIG5vclxuICAgICAgICAgICAgICAgIC8vIHRoZSB1bmRlcmx5aW5nIHNlYXJjaFBhcmFtcy5cbiAgICAgICAgICAgICAgICBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuZGVzY3JpYmVIYXNDaGVja2luZ1N0cmluZ1Byb3BlcnR5KSgnc2VhcmNoUGFyYW1zJywgcHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIHN5bmNJT0RldihzdG9yZS5yb3V0ZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIG93bktleXMgKHRhcmdldCkge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgT2JqZWN0LmtleXMoc2VhcmNoUGFyYW1zKWAgb3Igc2ltaWxhcic7XG4gICAgICAgICAgICBzeW5jSU9EZXYoc3RvcmUucm91dGUsIGV4cHJlc3Npb24sIHVucHJveGllZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgQ2FjaGVkU2VhcmNoUGFyYW1zLnNldCh1bmRlcmx5aW5nU2VhcmNoUGFyYW1zLCBwcm94aWVkUHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb3hpZWRQcm9taXNlO1xufVxuZnVuY3Rpb24gc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uLCBtaXNzaW5nUHJvcGVydGllcykge1xuICAgIC8vIEluIGFsbCBjYXNlcyB3ZSB3YXJuIG5vcm1hbGx5XG4gICAgaWYgKG1pc3NpbmdQcm9wZXJ0aWVzICYmIG1pc3NpbmdQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgd2FybkZvckluY29tcGxldGVFbnVtZXJhdGlvbihyb3V0ZSwgZXhwcmVzc2lvbiwgbWlzc2luZ1Byb3BlcnRpZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5Gb3JTeW5jQWNjZXNzKHJvdXRlLCBleHByZXNzaW9uKTtcbiAgICB9XG4gICAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IF93b3JrdW5pdGFzeW5jc3RvcmFnZWV4dGVybmFsLndvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgaWYgKHdvcmtVbml0U3RvcmUgJiYgd29ya1VuaXRTdG9yZS50eXBlID09PSAncmVxdWVzdCcgJiYgd29ya1VuaXRTdG9yZS5wcmVyZW5kZXJQaGFzZSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBXaGVuIHdlJ3JlIHJlbmRlcmluZyBkeW5hbWljYWxseSBpbiBkZXYgd2UgbmVlZCB0byBhZHZhbmNlIG91dCBvZiB0aGVcbiAgICAgICAgLy8gUHJlcmVuZGVyIGVudmlyb25tZW50IHdoZW4gd2UgcmVhZCBSZXF1ZXN0IGRhdGEgc3luY2hyb25vdXNseVxuICAgICAgICBjb25zdCByZXF1ZXN0U3RvcmUgPSB3b3JrVW5pdFN0b3JlO1xuICAgICAgICAoMCwgX2R5bmFtaWNyZW5kZXJpbmcudHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYpKHJlcXVlc3RTdG9yZSk7XG4gICAgfVxufVxuY29uc3Qgbm9vcCA9ICgpPT57fTtcbmNvbnN0IHdhcm5Gb3JTeW5jQWNjZXNzID0gcHJvY2Vzcy5lbnYuX19ORVhUX0RJU0FCTEVfU1lOQ19EWU5BTUlDX0FQSV9XQVJOSU5HUyA/IG5vb3AgOiAoMCwgX2NyZWF0ZWRlZHVwZWRieWNhbGxzaXRlc2VydmVyZXJyb3Jsb2dnZXIuY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldikoY3JlYXRlU2VhcmNoQWNjZXNzRXJyb3IpO1xuY29uc3Qgd2FybkZvckluY29tcGxldGVFbnVtZXJhdGlvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ESVNBQkxFX1NZTkNfRFlOQU1JQ19BUElfV0FSTklOR1MgPyBub29wIDogKDAsIF9jcmVhdGVkZWR1cGVkYnljYWxsc2l0ZXNlcnZlcmVycm9ybG9nZ2VyLmNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYpKGNyZWF0ZUluY29tcGxldGVFbnVtZXJhdGlvbkVycm9yKTtcbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaEFjY2Vzc0Vycm9yKHJvdXRlLCBleHByZXNzaW9uKSB7XG4gICAgY29uc3QgcHJlZml4ID0gcm91dGUgPyBgUm91dGUgXCIke3JvdXRlfVwiIGAgOiAnVGhpcyByb3V0ZSAnO1xuICAgIHJldHVybiBuZXcgRXJyb3IoYCR7cHJlZml4fXVzZWQgJHtleHByZXNzaW9ufS4gYCArIGBcXGBzZWFyY2hQYXJhbXNcXGAgc2hvdWxkIGJlIGF3YWl0ZWQgYmVmb3JlIHVzaW5nIGl0cyBwcm9wZXJ0aWVzLiBgICsgYExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3N5bmMtZHluYW1pYy1hcGlzYCk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbmNvbXBsZXRlRW51bWVyYXRpb25FcnJvcihyb3V0ZSwgZXhwcmVzc2lvbiwgbWlzc2luZ1Byb3BlcnRpZXMpIHtcbiAgICBjb25zdCBwcmVmaXggPSByb3V0ZSA/IGBSb3V0ZSBcIiR7cm91dGV9XCIgYCA6ICdUaGlzIHJvdXRlICc7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihgJHtwcmVmaXh9dXNlZCAke2V4cHJlc3Npb259LiBgICsgYFxcYHNlYXJjaFBhcmFtc1xcYCBzaG91bGQgYmUgYXdhaXRlZCBiZWZvcmUgdXNpbmcgaXRzIHByb3BlcnRpZXMuIGAgKyBgVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIHdlcmUgbm90IGF2YWlsYWJsZSB0aHJvdWdoIGVudW1lcmF0aW9uIGAgKyBgYmVjYXVzZSB0aGV5IGNvbmZsaWN0IHdpdGggYnVpbHRpbiBvciB3ZWxsLWtub3duIHByb3BlcnR5IG5hbWVzOiBgICsgYCR7ZGVzY3JpYmVMaXN0T2ZQcm9wZXJ0eU5hbWVzKG1pc3NpbmdQcm9wZXJ0aWVzKX0uIGAgKyBgTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvc3luYy1keW5hbWljLWFwaXNgKTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlTGlzdE9mUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKSB7XG4gICAgc3dpdGNoKHByb3BlcnRpZXMubGVuZ3RoKXtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdGhyb3cgbmV3IF9pbnZhcmlhbnRlcnJvci5JbnZhcmlhbnRFcnJvcignRXhwZWN0ZWQgZGVzY3JpYmVMaXN0T2ZQcm9wZXJ0eU5hbWVzIHRvIGJlIGNhbGxlZCB3aXRoIGEgbm9uLWVtcHR5IGxpc3Qgb2Ygc3RyaW5ncy4nKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGBcXGAke3Byb3BlcnRpZXNbMF19XFxgYDtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIGBcXGAke3Byb3BlcnRpZXNbMF19XFxgIGFuZCBcXGAke3Byb3BlcnRpZXNbMV19XFxgYDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVzY3JpcHRpb24gPSAnJztcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGggLSAxOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiArPSBgXFxgJHtwcm9wZXJ0aWVzW2ldfVxcYCwgYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gKz0gYCwgYW5kIFxcYCR7cHJvcGVydGllc1twcm9wZXJ0aWVzLmxlbmd0aCAtIDFdfVxcYGA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VhcmNoLXBhcmFtcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/server/request/search-params.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/client-page.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/client/components/client-page.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ClientPageRoot\", ({\n    enumerable: true,\n    get: function() {\n        return ClientPageRoot;\n    }\n}));\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\");\nfunction ClientPageRoot(param) {\n    let { Component, searchParams, params, promises } = param;\n    if (typeof window === 'undefined') {\n        const { workAsyncStorage } = __webpack_require__(/*! ../../server/app-render/work-async-storage.external */ \"(shared)/./node_modules/next/dist/server/app-render/work-async-storage.external.js?4f2c\");\n        let clientSearchParams;\n        let clientParams;\n        // We are going to instrument the searchParams prop with tracking for the\n        // appropriate context. We wrap differently in prerendering vs rendering\n        const store = workAsyncStorage.getStore();\n        if (!store) {\n            throw new _invarianterror.InvariantError('Expected workStore to exist when handling searchParams in a client Page.');\n        }\n        const { createSearchParamsFromClient } = __webpack_require__(/*! ../../server/request/search-params */ \"(app-pages-browser)/./node_modules/next/dist/server/request/search-params.js\");\n        clientSearchParams = createSearchParamsFromClient(searchParams, store);\n        const { createParamsFromClient } = __webpack_require__(/*! ../../server/request/params */ \"(app-pages-browser)/./node_modules/next/dist/server/request/params.js\");\n        clientParams = createParamsFromClient(params, store);\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {\n            params: clientParams,\n            searchParams: clientSearchParams\n        });\n    } else {\n        const { createRenderSearchParamsFromClient } = __webpack_require__(/*! ../../server/request/search-params.browser */ \"(app-pages-browser)/./node_modules/next/dist/server/request/search-params.browser.js\");\n        const clientSearchParams = createRenderSearchParamsFromClient(searchParams);\n        const { createRenderParamsFromClient } = __webpack_require__(/*! ../../server/request/params.browser */ \"(app-pages-browser)/./node_modules/next/dist/server/request/params.browser.js\");\n        const clientParams = createRenderParamsFromClient(params);\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {\n            params: clientParams,\n            searchParams: clientSearchParams\n        });\n    }\n}\n_c = ClientPageRoot;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=client-page.js.map\nvar _c;\n$RefreshReg$(_c, \"ClientPageRoot\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvY2xpZW50LXBhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7OztrREFlZ0JBOzs7ZUFBQUE7Ozs7NENBWmU7QUFZeEIsd0JBQXdCLEtBVzlCO0lBWDhCLE1BQzdCQyxTQUFTLEVBQ1RDLFlBQVksRUFDWkMsTUFBTSxFQUNOLFFBQ1EsRUFNVCxHQVg4QjtJQVk3QixJQUFJLE9BQU9FLFdBQVcsYUFBYTtRQUNqQyxNQUFNLEVBQUVDLGdCQUFnQixFQUFFLEdBQ3hCQyxtQkFBT0EsQ0FBQyxvSkFBcUQ7UUFFL0QsSUFBSUM7UUFDSixJQUFJQztRQUNKLHlFQUF5RTtRQUN6RSx3RUFBd0U7UUFDeEUsTUFBTUMsUUFBUUosaUJBQWlCSyxRQUFRO1FBQ3ZDLElBQUksQ0FBQ0QsT0FBTztZQUNWLE1BQU0sSUFBSUUsZ0JBQUFBLGNBQWMsQ0FDdEI7UUFFSjtRQUVBLE1BQU0sRUFBRUMsNEJBQTRCLEVBQUUsR0FDcENOLG1CQUFPQSxDQUFDLHdIQUFvQztRQUM5Q0MscUJBQXFCSyw2QkFBNkJYLGNBQWNRO1FBRWhFLE1BQU0sRUFBRUksc0JBQXNCLEVBQUUsR0FDOUJQLG1CQUFPQSxDQUFDLDBHQUE2QjtRQUN2Q0UsZUFBZUssdUJBQXVCWCxRQUFRTztRQUU5QyxxQkFBTyxxQkFBQ1QsV0FBQUE7WUFBVUUsUUFBUU07WUFBY1AsY0FBY007O0lBQ3hELE9BQU87UUFDTCxNQUFNLEVBQUVPLGtDQUFrQyxFQUFFLEdBQzFDUixtQkFBT0EsQ0FBQyx3SUFBNEM7UUFDdEQsTUFBTUMscUJBQXFCTyxtQ0FBbUNiO1FBQzlELE1BQU0sRUFBRWMsNEJBQTRCLEVBQUUsR0FDcENULG1CQUFPQSxDQUFDLDBIQUFxQztRQUMvQyxNQUFNRSxlQUFlTyw2QkFBNkJiO1FBRWxELHFCQUFPLHFCQUFDRixXQUFBQTtZQUFVRSxRQUFRTTtZQUFjUCxjQUFjTTs7SUFDeEQ7QUFDRjtLQTlDZ0JSIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxjbGllbnQtcGFnZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB0eXBlIHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB7IEludmFyaWFudEVycm9yIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3InXG5cbmltcG9ydCB0eXBlIHsgUGFyYW1zIH0gZnJvbSAnLi4vLi4vc2VydmVyL3JlcXVlc3QvcGFyYW1zJ1xuXG4vKipcbiAqIFdoZW4gdGhlIFBhZ2UgaXMgYSBjbGllbnQgY29tcG9uZW50IHdlIHNlbmQgdGhlIHBhcmFtcyBhbmQgc2VhcmNoUGFyYW1zIHRvIHRoaXMgY2xpZW50IHdyYXBwZXJcbiAqIHdoZXJlIHRoZXkgYXJlIHR1cm5lZCBpbnRvIGR5bmFtaWNhbGx5IHRyYWNrZWQgdmFsdWVzIGJlZm9yZSBiZWluZyBwYXNzZWQgdG8gdGhlIGFjdHVhbCBQYWdlIGNvbXBvbmVudC5cbiAqXG4gKiBhZGRpdGlvbmFsbHkgd2UgbWF5IHNlbmQgcHJvbWlzZXMgcmVwcmVzZW50aW5nIHRoZSBwYXJhbXMgYW5kIHNlYXJjaFBhcmFtcy4gV2UgZG9uJ3QgZXZlciB1c2UgdGhlc2UgcGFzc2VkXG4gKiB2YWx1ZXMgYnV0IGl0IGNhbiBiZSBuZWNlc3NhcnkgZm9yIHRoZSBzZW5kZXIgdG8gc2VuZCBhIFByb21pc2UgdGhhdCBkb2Vzbid0IHJlc29sdmUgaW4gY2VydGFpbiBzaXR1YXRpb25zLlxuICogSXQgaXMgdXAgdG8gdGhlIGNhbGxlciB0byBkZWNpZGUgaWYgdGhlIHByb21pc2VzIGFyZSBuZWVkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBDbGllbnRQYWdlUm9vdCh7XG4gIENvbXBvbmVudCxcbiAgc2VhcmNoUGFyYW1zLFxuICBwYXJhbXMsXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcHJvbWlzZXMsXG59OiB7XG4gIENvbXBvbmVudDogUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+XG4gIHNlYXJjaFBhcmFtczogUGFyc2VkVXJsUXVlcnlcbiAgcGFyYW1zOiBQYXJhbXNcbiAgcHJvbWlzZXM/OiBBcnJheTxQcm9taXNlPGFueT4+XG59KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IHsgd29ya0FzeW5jU3RvcmFnZSB9ID1cbiAgICAgIHJlcXVpcmUoJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCcpXG5cbiAgICBsZXQgY2xpZW50U2VhcmNoUGFyYW1zOiBQcm9taXNlPFBhcnNlZFVybFF1ZXJ5PlxuICAgIGxldCBjbGllbnRQYXJhbXM6IFByb21pc2U8UGFyYW1zPlxuICAgIC8vIFdlIGFyZSBnb2luZyB0byBpbnN0cnVtZW50IHRoZSBzZWFyY2hQYXJhbXMgcHJvcCB3aXRoIHRyYWNraW5nIGZvciB0aGVcbiAgICAvLyBhcHByb3ByaWF0ZSBjb250ZXh0LiBXZSB3cmFwIGRpZmZlcmVudGx5IGluIHByZXJlbmRlcmluZyB2cyByZW5kZXJpbmdcbiAgICBjb25zdCBzdG9yZSA9IHdvcmtBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICAgIGlmICghc3RvcmUpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhcmlhbnRFcnJvcihcbiAgICAgICAgJ0V4cGVjdGVkIHdvcmtTdG9yZSB0byBleGlzdCB3aGVuIGhhbmRsaW5nIHNlYXJjaFBhcmFtcyBpbiBhIGNsaWVudCBQYWdlLidcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCB7IGNyZWF0ZVNlYXJjaFBhcmFtc0Zyb21DbGllbnQgfSA9XG4gICAgICByZXF1aXJlKCcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9zZWFyY2gtcGFyYW1zJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vc2VydmVyL3JlcXVlc3Qvc2VhcmNoLXBhcmFtcycpXG4gICAgY2xpZW50U2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zRnJvbUNsaWVudChzZWFyY2hQYXJhbXMsIHN0b3JlKVxuXG4gICAgY29uc3QgeyBjcmVhdGVQYXJhbXNGcm9tQ2xpZW50IH0gPVxuICAgICAgcmVxdWlyZSgnLi4vLi4vc2VydmVyL3JlcXVlc3QvcGFyYW1zJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vc2VydmVyL3JlcXVlc3QvcGFyYW1zJylcbiAgICBjbGllbnRQYXJhbXMgPSBjcmVhdGVQYXJhbXNGcm9tQ2xpZW50KHBhcmFtcywgc3RvcmUpXG5cbiAgICByZXR1cm4gPENvbXBvbmVudCBwYXJhbXM9e2NsaWVudFBhcmFtc30gc2VhcmNoUGFyYW1zPXtjbGllbnRTZWFyY2hQYXJhbXN9IC8+XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgeyBjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXNGcm9tQ2xpZW50IH0gPVxuICAgICAgcmVxdWlyZSgnLi4vLi4vc2VydmVyL3JlcXVlc3Qvc2VhcmNoLXBhcmFtcy5icm93c2VyJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vc2VydmVyL3JlcXVlc3Qvc2VhcmNoLXBhcmFtcy5icm93c2VyJylcbiAgICBjb25zdCBjbGllbnRTZWFyY2hQYXJhbXMgPSBjcmVhdGVSZW5kZXJTZWFyY2hQYXJhbXNGcm9tQ2xpZW50KHNlYXJjaFBhcmFtcylcbiAgICBjb25zdCB7IGNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQgfSA9XG4gICAgICByZXF1aXJlKCcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMuYnJvd3NlcicpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcy5icm93c2VyJylcbiAgICBjb25zdCBjbGllbnRQYXJhbXMgPSBjcmVhdGVSZW5kZXJQYXJhbXNGcm9tQ2xpZW50KHBhcmFtcylcblxuICAgIHJldHVybiA8Q29tcG9uZW50IHBhcmFtcz17Y2xpZW50UGFyYW1zfSBzZWFyY2hQYXJhbXM9e2NsaWVudFNlYXJjaFBhcmFtc30gLz5cbiAgfVxufVxuIl0sIm5hbWVzIjpbIkNsaWVudFBhZ2VSb290IiwiQ29tcG9uZW50Iiwic2VhcmNoUGFyYW1zIiwicGFyYW1zIiwicHJvbWlzZXMiLCJ3aW5kb3ciLCJ3b3JrQXN5bmNTdG9yYWdlIiwicmVxdWlyZSIsImNsaWVudFNlYXJjaFBhcmFtcyIsImNsaWVudFBhcmFtcyIsInN0b3JlIiwiZ2V0U3RvcmUiLCJJbnZhcmlhbnRFcnJvciIsImNyZWF0ZVNlYXJjaFBhcmFtc0Zyb21DbGllbnQiLCJjcmVhdGVQYXJhbXNGcm9tQ2xpZW50IiwiY3JlYXRlUmVuZGVyU2VhcmNoUGFyYW1zRnJvbUNsaWVudCIsImNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/client-page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/client-segment.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/client-segment.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ClientSegmentRoot\", ({\n    enumerable: true,\n    get: function() {\n        return ClientSegmentRoot;\n    }\n}));\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\");\nfunction ClientSegmentRoot(param) {\n    let { Component, slots, params, promise } = param;\n    if (typeof window === 'undefined') {\n        const { workAsyncStorage } = __webpack_require__(/*! ../../server/app-render/work-async-storage.external */ \"(shared)/./node_modules/next/dist/server/app-render/work-async-storage.external.js?4f2c\");\n        let clientParams;\n        // We are going to instrument the searchParams prop with tracking for the\n        // appropriate context. We wrap differently in prerendering vs rendering\n        const store = workAsyncStorage.getStore();\n        if (!store) {\n            throw new _invarianterror.InvariantError('Expected workStore to exist when handling params in a client segment such as a Layout or Template.');\n        }\n        const { createParamsFromClient } = __webpack_require__(/*! ../../server/request/params */ \"(app-pages-browser)/./node_modules/next/dist/server/request/params.js\");\n        clientParams = createParamsFromClient(params, store);\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {\n            ...slots,\n            params: clientParams\n        });\n    } else {\n        const { createRenderParamsFromClient } = __webpack_require__(/*! ../../server/request/params.browser */ \"(app-pages-browser)/./node_modules/next/dist/server/request/params.browser.js\");\n        const clientParams = createRenderParamsFromClient(params);\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(Component, {\n            ...slots,\n            params: clientParams\n        });\n    }\n}\n_c = ClientSegmentRoot;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=client-segment.js.map\nvar _c;\n$RefreshReg$(_c, \"ClientSegmentRoot\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvY2xpZW50LXNlZ21lbnQuanMiLCJtYXBwaW5ncyI6Ijs7OztxREFjZ0JBOzs7ZUFBQUE7Ozs7NENBWmU7QUFZeEIsMkJBQTJCLEtBV2pDO0lBWGlDLE1BQ2hDQyxTQUFTLEVBQ1RDLEtBQUssRUFDTEMsTUFBTSxFQUNOLE9BQ08sRUFNUixHQVhpQztJQVloQyxJQUFJLE9BQU9FLFdBQVcsYUFBYTtRQUNqQyxNQUFNLEVBQUVDLGdCQUFnQixFQUFFLEdBQ3hCQyxtQkFBT0EsQ0FBQyxvSkFBcUQ7UUFFL0QsSUFBSUM7UUFDSix5RUFBeUU7UUFDekUsd0VBQXdFO1FBQ3hFLE1BQU1DLFFBQVFILGlCQUFpQkksUUFBUTtRQUN2QyxJQUFJLENBQUNELE9BQU87WUFDVixNQUFNLElBQUlFLGdCQUFBQSxjQUFjLENBQ3RCO1FBRUo7UUFFQSxNQUFNLEVBQUVDLHNCQUFzQixFQUFFLEdBQzlCTCxtQkFBT0EsQ0FBQywwR0FBNkI7UUFDdkNDLGVBQWVJLHVCQUF1QlQsUUFBUU07UUFFOUMscUJBQU8scUJBQUNSLFdBQUFBO1lBQVcsR0FBR0MsS0FBSztZQUFFQyxRQUFRSzs7SUFDdkMsT0FBTztRQUNMLE1BQU0sRUFBRUssNEJBQTRCLEVBQUUsR0FDcENOLG1CQUFPQSxDQUFDLDBIQUFxQztRQUMvQyxNQUFNQyxlQUFlSyw2QkFBNkJWO1FBQ2xELHFCQUFPLHFCQUFDRixXQUFBQTtZQUFXLEdBQUdDLEtBQUs7WUFBRUMsUUFBUUs7O0lBQ3ZDO0FBQ0Y7S0FyQ2dCUiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzcmNcXGNsaWVudFxcY29tcG9uZW50c1xcY2xpZW50LXNlZ21lbnQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgeyBJbnZhcmlhbnRFcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaW52YXJpYW50LWVycm9yJ1xuXG5pbXBvcnQgdHlwZSB7IFBhcmFtcyB9IGZyb20gJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcydcblxuLyoqXG4gKiBXaGVuIHRoZSBQYWdlIGlzIGEgY2xpZW50IGNvbXBvbmVudCB3ZSBzZW5kIHRoZSBwYXJhbXMgdG8gdGhpcyBjbGllbnQgd3JhcHBlclxuICogd2hlcmUgdGhleSBhcmUgdHVybmVkIGludG8gZHluYW1pY2FsbHkgdHJhY2tlZCB2YWx1ZXMgYmVmb3JlIGJlaW5nIHBhc3NlZCB0byB0aGUgYWN0dWFsIFNlZ21lbnQgY29tcG9uZW50LlxuICpcbiAqIGFkZGl0aW9uYWxseSB3ZSBtYXkgc2VuZCBhIHByb21pc2UgcmVwcmVzZW50aW5nIHBhcmFtcy4gV2UgZG9uJ3QgZXZlciB1c2UgdGhpcyBwYXNzZWRcbiAqIHZhbHVlIGJ1dCBpdCBjYW4gYmUgbmVjZXNzYXJ5IGZvciB0aGUgc2VuZGVyIHRvIHNlbmQgYSBQcm9taXNlIHRoYXQgZG9lc24ndCByZXNvbHZlIGluIGNlcnRhaW4gc2l0dWF0aW9uc1xuICogc3VjaCBhcyB3aGVuIGR5bmFtaWNJTyBpcyBlbmFibGVkLiBJdCBpcyB1cCB0byB0aGUgY2FsbGVyIHRvIGRlY2lkZSBpZiB0aGUgcHJvbWlzZXMgYXJlIG5lZWRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENsaWVudFNlZ21lbnRSb290KHtcbiAgQ29tcG9uZW50LFxuICBzbG90cyxcbiAgcGFyYW1zLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHByb21pc2UsXG59OiB7XG4gIENvbXBvbmVudDogUmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+XG4gIHNsb3RzOiB7IFtrZXk6IHN0cmluZ106IFJlYWN0LlJlYWN0Tm9kZSB9XG4gIHBhcmFtczogUGFyYW1zXG4gIHByb21pc2U/OiBQcm9taXNlPGFueT5cbn0pIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgeyB3b3JrQXN5bmNTdG9yYWdlIH0gPVxuICAgICAgcmVxdWlyZSgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJylcblxuICAgIGxldCBjbGllbnRQYXJhbXM6IFByb21pc2U8UGFyYW1zPlxuICAgIC8vIFdlIGFyZSBnb2luZyB0byBpbnN0cnVtZW50IHRoZSBzZWFyY2hQYXJhbXMgcHJvcCB3aXRoIHRyYWNraW5nIGZvciB0aGVcbiAgICAvLyBhcHByb3ByaWF0ZSBjb250ZXh0LiBXZSB3cmFwIGRpZmZlcmVudGx5IGluIHByZXJlbmRlcmluZyB2cyByZW5kZXJpbmdcbiAgICBjb25zdCBzdG9yZSA9IHdvcmtBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICAgIGlmICghc3RvcmUpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhcmlhbnRFcnJvcihcbiAgICAgICAgJ0V4cGVjdGVkIHdvcmtTdG9yZSB0byBleGlzdCB3aGVuIGhhbmRsaW5nIHBhcmFtcyBpbiBhIGNsaWVudCBzZWdtZW50IHN1Y2ggYXMgYSBMYXlvdXQgb3IgVGVtcGxhdGUuJ1xuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHsgY3JlYXRlUGFyYW1zRnJvbUNsaWVudCB9ID1cbiAgICAgIHJlcXVpcmUoJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcycpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcycpXG4gICAgY2xpZW50UGFyYW1zID0gY3JlYXRlUGFyYW1zRnJvbUNsaWVudChwYXJhbXMsIHN0b3JlKVxuXG4gICAgcmV0dXJuIDxDb21wb25lbnQgey4uLnNsb3RzfSBwYXJhbXM9e2NsaWVudFBhcmFtc30gLz5cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7IGNyZWF0ZVJlbmRlclBhcmFtc0Zyb21DbGllbnQgfSA9XG4gICAgICByZXF1aXJlKCcuLi8uLi9zZXJ2ZXIvcmVxdWVzdC9wYXJhbXMuYnJvd3NlcicpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcy5icm93c2VyJylcbiAgICBjb25zdCBjbGllbnRQYXJhbXMgPSBjcmVhdGVSZW5kZXJQYXJhbXNGcm9tQ2xpZW50KHBhcmFtcylcbiAgICByZXR1cm4gPENvbXBvbmVudCB7Li4uc2xvdHN9IHBhcmFtcz17Y2xpZW50UGFyYW1zfSAvPlxuICB9XG59XG4iXSwibmFtZXMiOlsiQ2xpZW50U2VnbWVudFJvb3QiLCJDb21wb25lbnQiLCJzbG90cyIsInBhcmFtcyIsInByb21pc2UiLCJ3aW5kb3ciLCJ3b3JrQXN5bmNTdG9yYWdlIiwicmVxdWlyZSIsImNsaWVudFBhcmFtcyIsInN0b3JlIiwiZ2V0U3RvcmUiLCJJbnZhcmlhbnRFcnJvciIsImNyZWF0ZVBhcmFtc0Zyb21DbGllbnQiLCJjcmVhdGVSZW5kZXJQYXJhbXNGcm9tQ2xpZW50Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/client-segment.js\n"));

/***/ })

});