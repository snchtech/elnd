Чудово. Нижче — готова схема для **журналу запитів** + кілька корисних додаткових полів, індекси, а також приклад процесу в APEX для вставки запису з IP/UA/кнопки.

# 1) Таблиця журналу запитів

Варіант **(А)** для Oracle 12c+ (IDENTITY) і **(Б)** для 10g/11g (sequence+trigger). Обери свій.

## (А) Oracle 12c+ — IDENTITY

```sql
CREATE TABLE REQUEST_LOG (
  ID               NUMBER GENERATED BY DEFAULT AS IDENTITY
                       CONSTRAINT PK_REQUEST_LOG PRIMARY KEY,
  USER_ID          NUMBER       NOT NULL,
  DEVICE_IP        VARCHAR2(45) NOT NULL, -- IPv4/IPv6
  REQUEST_ACTION   VARCHAR2(10) NOT NULL, -- LOGIN / LOGOUT
  REQUEST_DATE     TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,

  -- ДОДАТКОВО (рекомендовано)
  SESSION_ID       VARCHAR2(64),          -- v('APP_SESSION')
  RESULT_STATUS    VARCHAR2(10) DEFAULT 'SUCCESS' -- SUCCESS / FAIL
                     CONSTRAINT CK_REQLOG_RESULT CHECK (RESULT_STATUS IN ('SUCCESS','FAIL')),
  ERROR_CODE       VARCHAR2(50),
  ERROR_MESSAGE    VARCHAR2(4000),
  USER_AGENT       VARCHAR2(255),
  REQUEST_SOURCE   VARCHAR2(30) DEFAULT 'FORM', -- FORM / API / JOB
  DEVICE_ID        NUMBER,               -- якщо згодом з’явиться таблиця DEVICES
  OFFICE_ID        NUMBER,               -- денормалізоване поле, якщо з IP визначаємо офіс

  CONSTRAINT CK_REQLOG_ACTION CHECK (REQUEST_ACTION IN ('LOGIN','LOGOUT'))
);

-- FK до таблиці користувачів (назву таблиці підстав свого середовища)
ALTER TABLE REQUEST_LOG
  ADD CONSTRAINT FK_REQLOG_USER
  FOREIGN KEY (USER_ID) REFERENCES USERS(USER_ID);

-- Індекси під найчастіші вибірки
CREATE INDEX IX_REQLOG_USER_DATE ON REQUEST_LOG (USER_ID, REQUEST_DATE);
CREATE INDEX IX_REQLOG_DATE      ON REQUEST_LOG (REQUEST_DATE);
CREATE INDEX IX_REQLOG_IP_DATE   ON REQUEST_LOG (DEVICE_IP, REQUEST_DATE);
CREATE INDEX IX_REQLOG_ACTION_DT ON REQUEST_LOG (REQUEST_ACTION, REQUEST_DATE);
```

## (Б) Oracle 10g/11g — послідовність + тригер

```sql
CREATE TABLE REQUEST_LOG (
  ID               NUMBER       CONSTRAINT PK_REQUEST_LOG PRIMARY KEY,
  USER_ID          NUMBER       NOT NULL,
  DEVICE_IP        VARCHAR2(45) NOT NULL,
  REQUEST_ACTION   VARCHAR2(10) NOT NULL,
  REQUEST_DATE     TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,

  SESSION_ID       VARCHAR2(64),
  RESULT_STATUS    VARCHAR2(10) DEFAULT 'SUCCESS'
                     CONSTRAINT CK_REQLOG_RESULT CHECK (RESULT_STATUS IN ('SUCCESS','FAIL')),
  ERROR_CODE       VARCHAR2(50),
  ERROR_MESSAGE    VARCHAR2(4000),
  USER_AGENT       VARCHAR2(255),
  REQUEST_SOURCE   VARCHAR2(30) DEFAULT 'FORM',
  DEVICE_ID        NUMBER,
  OFFICE_ID        NUMBER,

  CONSTRAINT CK_REQLOG_ACTION CHECK (REQUEST_ACTION IN ('LOGIN','LOGOUT'))
);

ALTER TABLE REQUEST_LOG
  ADD CONSTRAINT FK_REQLOG_USER
  FOREIGN KEY (USER_ID) REFERENCES USERS(USER_ID);

CREATE SEQUENCE REQUEST_LOG_SEQ START WITH 1 NOCACHE;

CREATE OR REPLACE TRIGGER BI_REQUEST_LOG
BEFORE INSERT ON REQUEST_LOG
FOR EACH ROW
BEGIN
  IF :NEW.ID IS NULL THEN
    :NEW.ID := REQUEST_LOG_SEQ.NEXTVAL;
  END IF;
END;
/

CREATE INDEX IX_REQLOG_USER_DATE ON REQUEST_LOG (USER_ID, REQUEST_DATE);
CREATE INDEX IX_REQLOG_DATE      ON REQUEST_LOG (REQUEST_DATE);
CREATE INDEX IX_REQLOG_IP_DATE   ON REQUEST_LOG (DEVICE_IP, REQUEST_DATE);
CREATE INDEX IX_REQLOG_ACTION_DT ON REQUEST_LOG (REQUEST_ACTION, REQUEST_DATE);
```

> **Чому ці поля корисні:**
>
> * `SESSION_ID` — швидко знаходити події в межах APEX‑сесії.
> * `RESULT_STATUS`, `ERROR_*` — прозорий аудит: чому не вдалось.
> * `USER_AGENT` — діагностика клієнтів (браузери/термінали).
> * `REQUEST_SOURCE` — відрізнити запити з UI/REST/фонових job’ів.
> * `DEVICE_ID`, `OFFICE_ID` — за потреби збагачення записів (з твого `DEVICES_OFFICE` або окремих `DEVICES`/`OFFICES`). FK можна додати пізніше, коли буде остаточна модель.

---

# 2) Як писати записи з APEX (процес сторінки)

У кнопок **Login**/**Logout** постав **Request** відповідно `LOGIN` і `LOGOUT`.
Створи **Process → PL/SQL** (після валідацій).

```plsql
DECLARE
  l_ip  VARCHAR2(45);
  l_ua  VARCHAR2(255);
  l_req VARCHAR2(20);
BEGIN
  -- IP та User-Agent з CGI
  l_ip  := owa_util.get_cgi_env('REMOTE_ADDR');
  l_ua  := SUBSTR(owa_util.get_cgi_env('HTTP_USER_AGENT'), 1, 255);

  -- Яка кнопка натиснута (запит APEX)
  l_req := NVL(v('REQUEST'), 'LOGIN'); -- дефолт на всяк випадок

  INSERT INTO REQUEST_LOG (
    USER_ID,
    DEVICE_IP,
    REQUEST_ACTION,
    REQUEST_DATE,
    SESSION_ID,
    USER_AGENT,
    REQUEST_SOURCE,
    RESULT_STATUS
  )
  VALUES (
    TO_NUMBER(:P10_NUMBER),   -- твоє числове поле з форми
    l_ip,
    l_req,
    SYSTIMESTAMP,
    v('APP_SESSION'),
    l_ua,
    'FORM',
    'SUCCESS'                 -- або поставиш FAIL у гілці EXCEPTION
  );
EXCEPTION
  WHEN OTHERS THEN
    INSERT INTO REQUEST_LOG (
      USER_ID, DEVICE_IP, REQUEST_ACTION, REQUEST_DATE,
      SESSION_ID, USER_AGENT, REQUEST_SOURCE,
      RESULT_STATUS, ERROR_CODE, ERROR_MESSAGE
    )
    VALUES (
      CASE WHEN REGEXP_LIKE(:P10_NUMBER, '^\d+$') THEN TO_NUMBER(:P10_NUMBER) ELSE NULL END,
      NVL(l_ip, 'UNKNOWN'),
      NVL(l_req, 'LOGIN'),
      SYSTIMESTAMP,
      v('APP_SESSION'),
      l_ua,
      'FORM',
      'FAIL',
      SQLCODE,
      SUBSTR(SQLERRM,1,4000)
    );
    RAISE;
END;
```

> Якщо хочеш **автоматично визначати `OFFICE_ID`**, додай у процес SELECT з твоєї `DEVICES_OFFICE` (або через таблицю `DEVICES`, якщо IP → DEVICE\_ID), і підставляй значення у `INSERT`.

---

# 3) (Опційно) партиціювання для великих обсягів

Якщо очікується багато записів і є Enterprise Edition:

```sql
-- приклад: партиції по місяцях за REQUEST_DATE
-- створюй відразу партиційовану таблицю або перенеси згодом (DBMS_REDEFINITION)
```

Це спростить архівацію/чистку за період.

---

# 4) Що ще варто фіксувати (рекомендації)

* `REQUEST_HASH` (наприклад, SHA1 від USER\_ID||ACTION||TRUNC(request\_date,'MI')) + унікальний індекс → захист від дублювань у короткому вікні.
* `APP_ID`, `PAGE_ID` (з APEX: `v('APP_ID')`, `v('APP_PAGE_ID')`) — зручно фільтрувати.
* `CREATED_BY` (наприклад, `v('APP_USER')`) — хто ініціював дію.
* `LATENCY_MS` (якщо є зовнішні виклики) — для моніторингу швидкодії.
* `COMMENTS` (короткі технічні примітки).

Хочеш — можу під це все підготувати мінімальний **view** для зручного звіту (з приєднанням імені користувача з `USERS`) і **політику очистки** (job на PURGE старіше N днів).
