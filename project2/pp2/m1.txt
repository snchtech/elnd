Чудово, робимо універсальний підхід: одна таблиця відповідностей **USER\_NFC**, один вхідний параметр (рядок), перевірка “або `USER_ID`, або `NFC_ID`”, фіксація **чим** автентифіковано (вручну чи міткою), і запис у `REQUEST_LOG`.

---

# 1) Таблиця відповідностей USER\_NFC

```sql
-- 12c+: IDENTITY; для 11g — послідовність+тригер
CREATE TABLE USER_NFC (
  ID        NUMBER GENERATED BY DEFAULT AS IDENTITY
              CONSTRAINT PK_USER_NFC PRIMARY KEY,
  USER_ID   NUMBER       NOT NULL,
  NFC_ID    VARCHAR2(64) NOT NULL, -- з запасом, під UID/HEX/DEC/мікси
  CREATED_AT TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL
);

-- Унікальність мітки та зв’язок із користувачем
ALTER TABLE USER_NFC
  ADD CONSTRAINT UQ_USER_NFC_NFC UNIQUE (NFC_ID);

ALTER TABLE USER_NFC
  ADD CONSTRAINT FK_USER_NFC_USER
  FOREIGN KEY (USER_ID) REFERENCES USERS(USER_ID);

-- Індекс на USER_ID (для зворотного пошуку)
CREATE INDEX IX_USER_NFC_USER ON USER_NFC (USER_ID);

-- (Необов’язково) перевірка формату NFC, якщо це HEX без розділювачів
-- ALTER TABLE USER_NFC ADD CONSTRAINT CK_USER_NFC_HEX
--   CHECK (REGEXP_LIKE(NFC_ID, '^[A-F0-9]{6,}$'));
```

### Нормалізація NFC (рекомендовано)

Зручно тримати NFC у **нормалізованому** вигляді (без пробілів/дво-крапок, у верхньому регістрі).
Додай невеличку функцію і використай її у формах/процесах вставки.

```sql
CREATE OR REPLACE FUNCTION norm_nfc(p IN VARCHAR2)
RETURN VARCHAR2 IS
BEGIN
  IF p IS NULL THEN RETURN NULL; END IF;
  -- прибрати все, що не літера/цифра; у верхній регістр
  RETURN UPPER(REGEXP_REPLACE(p, '[^[:alnum:]]', ''));
END;
/
```

---

# 2) Фіксація способу автентифікації

У твоєму `REQUEST_LOG` додаємо поле **AUTH\_METHOD** (або використовуємо `REQUEST_SOURCE`). Ясність краща, тож додамо:

```sql
ALTER TABLE REQUEST_LOG
  ADD AUTH_METHOD VARCHAR2(10)
      CONSTRAINT CK_REQLOG_AUTH CHECK (AUTH_METHOD IN ('MANUAL','NFC'));
```

> Де:
>
> * `MANUAL` — ввели цифри руками (ідентифікатор користувача),
> * `NFC` — зчитали мітку (рядок / HEX / UID).

---

# 3) Єдиний запит пошуку “або USER\_ID, або NFC\_ID”

В APEX зроби **один** інпут-айтем (Text Field) — напр. `P10_CODE` (бо NFC не завжди numeric).
Логіка визначення:

* Якщо `P10_CODE` **тільки цифри** → спробуємо знайти **USERS.USER\_ID**.
* Паралельно завжди пробуємо знайти `USER_NFC.NFC_ID = norm_nfc(:P10_CODE)`.
* Якщо знайдено обидва варіанти — визначаємо пріоритет (звич. пріоритет **NFC**, бо це явний носій).

### SQL, який повертає `USER_ID` + метод

```sql
WITH indata AS (
  SELECT :P10_CODE AS code, norm_nfc(:P10_CODE) AS code_nfc FROM dual
)
SELECT user_id, method
FROM (
  -- Пріоритет NFC
  SELECT n.user_id, 'NFC' AS method, 1 AS ord
    FROM USER_NFC n
    JOIN indata d ON n.NFC_ID = d.code_nfc
  UNION ALL
  -- MANUAL тільки якщо code — це цілі числа
  SELECT u.user_id, 'MANUAL' AS method, 2 AS ord
    FROM USERS u
    JOIN indata d ON REGEXP_LIKE(d.code, '^\d+$') AND u.USER_ID = TO_NUMBER(d.code)
)
ORDER BY ord
FETCH FIRST 1 ROW ONLY
```

---

# 4) AJAX‑процес у APEX: пошук + лог + відповідь для діалогу

**Process type:** *AJAX Callback*, ім’я `CHECK_OR_LOGIN` (можеш лишити “CHECK” якщо це просто перевірка).

```plsql
DECLARE
  l_code      VARCHAR2(400) := :P10_CODE;
  l_user_id   USERS.USER_ID%TYPE;
  l_method    VARCHAR2(10);
  l_exists    NUMBER;
  l_ts        VARCHAR2(16);
  l_ip        VARCHAR2(45)  := util_net.get_client_ip; -- з попередньої відповіді
  l_ua        VARCHAR2(255) := SUBSTR(owa_util.get_cgi_env('HTTP_USER_AGENT'),1,255);

  l_firstname USERS.USER_FIRSTNAME%TYPE;
  l_lastname  USERS.USER_LASTNAME%TYPE;
  l_depart    USERS.USER_DEPART%TYPE;
  l_position  USERS.USER_POSITION%TYPE;
BEGIN
  apex_json.open_object;

  IF l_code IS NULL THEN
    apex_json.write('ok', false);
    apex_json.write('message', 'Введіть код або піднесіть мітку.');
    apex_json.close_object;
    RETURN;
  END IF;

  -- Пошук: NFC має пріоритет
  BEGIN
    WITH indata AS (
      SELECT l_code AS code, norm_nfc(l_code) AS code_nfc FROM dual
    )
    SELECT user_id, method
      INTO l_user_id, l_method
      FROM (
        SELECT n.user_id, 'NFC' AS method, 1 AS ord
          FROM user_nfc n
          JOIN indata d ON n.nfc_id = d.code_nfc
        UNION ALL
        SELECT u.user_id, 'MANUAL' AS method, 2 AS ord
          FROM users u
          JOIN indata d
            ON REGEXP_LIKE(d.code,'^\d+$') AND u.user_id = TO_NUMBER(d.code)
      )
      ORDER BY ord
      FETCH FIRST 1 ROW ONLY;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      l_user_id := NULL;
  END;

  IF l_user_id IS NULL THEN
    -- Лог невдачі
    INSERT INTO request_log(
      user_id, device_ip, request_action, request_date,
      session_id, user_agent, request_source, result_status, auth_method, error_message
    ) VALUES (
      NULL, l_ip, 'CHECK', SYSTIMESTAMP,
      v('APP_SESSION'), l_ua, 'FORM', 'FAIL', NULL, 'User not found'
    );

    apex_json.write('ok', false);
    apex_json.write('message', 'Користувача не знайдено.');
    apex_json.close_object;
    RETURN;
  END IF;

  -- Дані користувача
  SELECT u.user_firstname, u.user_lastname, u.user_depart, u.user_position
    INTO l_firstname, l_lastname, l_depart, l_position
    FROM users u
   WHERE u.user_id = l_user_id;

  -- Фіксуємо успіх
  INSERT INTO request_log(
    user_id, device_ip, request_action, request_date,
    session_id, user_agent, request_source, result_status, auth_method
  ) VALUES (
    l_user_id, l_ip, 'CHECK', SYSTIMESTAMP,
    v('APP_SESSION'), l_ua, 'FORM', 'SUCCESS', l_method
  );

  SELECT to_char(SYSTIMESTAMP AT LOCAL TIME ZONE, 'dd.mm.yyyy hh24:mi')
    INTO l_ts FROM dual;

  -- Відповідь
  apex_json.write('ok', true);
  apex_json.write('ts', l_ts);
  apex_json.write('firstname', l_firstname);
  apex_json.write('lastname',  l_lastname);
  apex_json.write('depart',    l_depart);
  apex_json.write('position',  l_position);
  apex_json.write('authMethod', l_method);

  apex_json.close_object;
EXCEPTION
  WHEN OTHERS THEN
    INSERT INTO request_log(
      user_id, device_ip, request_action, request_date,
      session_id, user_agent, request_source, result_status, error_code, error_message
    ) VALUES (
      NULL, l_ip, 'CHECK', SYSTIMESTAMP,
      v('APP_SESSION'), l_ua, 'FORM', 'FAIL', SQLCODE, SUBSTR(SQLERRM,1,4000)
    );
    apex_json.open_object;
    apex_json.write('ok', false);
    apex_json.write('message', 'Системна помилка. Спробуйте ще раз.');
    apex_json.close_object;
END;
```

> Якщо в тебе вже є кнопка **OK** з попередніх кроків — просто заміни її JS на виклик цього процесу і підставляй дані у твій диалог.

---

# 5) APEX: що змінити на сторінці

* Поле вводу зроби **Text Field** `P10_CODE` (не Number), щоб дозволити і NFC.
  Можеш додати JS‑валідацію: **тільки цифри або HEX + розділювачі** → перед відправкою застосуй `norm_nfc()` на сервері.
* Кнопка **OK** → `javascript:submitCheck();` (як у попередніх відповідях).
* Діалогове вікно — уже є (успіх/помилка), просто додай відображення `authMethod` якщо хочеш (“Спосіб: мітка/вручну”).

---

# 6) Чи можна фіксувати «вручну чи міткою»?

Так — ми це вже робимо через `REQUEST_LOG.AUTH_METHOD = 'MANUAL' | 'NFC'`.
Додатково можеш зберегти **сирий ввід** (`RAW_INPUT`) для аудиту:

```sql
ALTER TABLE REQUEST_LOG ADD RAW_INPUT VARCHAR2(128);
```

і при вставці писати `RAW_INPUT := :P10_CODE`.

---

Хочеш — піджену все це в один **скрипт міграції (DDL+пакет+процес)** і невеликий **APEX export** для швидкого імпорту.
