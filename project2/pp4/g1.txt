Класна задача. Правильно, “парність записів” ламка. Нижче даю кілька стійких підходів (з плюсами/мінусами), готові DDL/індекси й приклади PL/SQL‑логіки, які переживають північ, кілька входів за зміну, різні термінали, пропущений logout тощо.

---

# Варіант A — Стан користувача + аудит (простий і надійний)

**Ідея:** тримаємо *поточний стан* у `USER_STATE`, а всю історію — в `REQUEST_LOG`. Не залежимо від добових меж.

## Схема

```sql
CREATE TABLE USER_STATE (
  USER_ID       NUMBER PRIMARY KEY,
  OPEN_FLAG     CHAR(1) NOT NULL CHECK (OPEN_FLAG IN ('Y','N')),
  LAST_LOGIN    TIMESTAMP WITH TIME ZONE,
  LAST_LOGOUT   TIMESTAMP WITH TIME ZONE,
  UPDATED_AT    TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
  UPDATED_IP    VARCHAR2(45),
  UPDATED_AGENT_ID NUMBER  -- якщо нормалізуєш user-agent
);
```

## Тогл (OK‑кнопка або скан)

* Беремо рядок `FOR UPDATE` → міняємо `OPEN_FLAG` Y↔N **атомарно**.
* Якщо запису нема — вважаємо перший вхід (LOGIN).
* У `REQUEST_LOG` пишемо подію `LOGIN/LOGOUT` з часом та `AUTH_METHOD`.

**Плюси:** мінімум складності, гарантія узгодженості, не важливо скільки разів за день.
**Мінуси:** для детальної звітності по інтервалах доведеться брати часові точки з `REQUEST_LOG`.

---

# Варіант B — Таблиця сесій (рекомендовано для змін/багаторазових входів)

**Ідея:** кожен вхід — рядок у `USER_SESSIONS`. Відкриті сесії мають `LOGOUT_DATE IS NULL`. Це дає ідеальні інтервали навіть через північ.

## Схема (1 сесія одночасно на користувача)

```sql
CREATE TABLE USER_SESSIONS (
  ID          NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  USER_ID     NUMBER NOT NULL,
  LOGIN_DATE  TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
  LOGOUT_DATE TIMESTAMP WITH TIME ZONE,
  DEVICE_IP   VARCHAR2(45),
  OFFICE_ID   NUMBER,
  AUTH_METHOD VARCHAR2(10) CHECK (AUTH_METHOD IN ('MANUAL','NFC')),
  USER_AGENT_ID NUMBER
);

-- Заборонити дві відкриті сесії одночасно на користувача:
CREATE UNIQUE INDEX UX_USER_OPEN_SESSION
  ON USER_SESSIONS (USER_ID, NVL(LOGOUT_DATE, DATE '4712-12-31'));
```

> Якщо потрібні *паралельні* входи з різних терміналів — змініть унікальність на `(USER_ID, COALESCE(DEVICE_IP, 'NONE'), NVL(LOGOUT_DATE, …))`.

## Логіка “OK” (тогл) у процесі APEX

```plsql
DECLARE
  l_ip     VARCHAR2(45) := util_net.get_client_ip;
  l_user   NUMBER := TO_NUMBER(:P10_CODE);
  l_opened NUMBER;
BEGIN
  -- Перевірка користувача … (пропущу)

  -- Є відкрита?
  SELECT COUNT(*) INTO l_opened
  FROM USER_SESSIONS
  WHERE USER_ID = l_user AND LOGOUT_DATE IS NULL
  FOR UPDATE; -- серіалізація

  IF l_opened = 1 THEN
    -- LOGOUT
    UPDATE USER_SESSIONS
       SET LOGOUT_DATE = SYSTIMESTAMP
     WHERE USER_ID = l_user
       AND LOGOUT_DATE IS NULL;

    INSERT INTO REQUEST_LOG (USER_ID, DEVICE_IP, REQUEST_ACTION, REQUEST_DATE,
                             RESULT_STATUS, REQUEST_SOURCE, AUTH_METHOD)
    VALUES (l_user, l_ip, 'LOGOUT', SYSTIMESTAMP,
            'SUCCESS', 'FORM', :P10_AUTH_METHOD);
  ELSE
    -- LOGIN
    INSERT INTO USER_SESSIONS (USER_ID, LOGIN_DATE, DEVICE_IP, OFFICE_ID,
                               AUTH_METHOD, USER_AGENT_ID)
    VALUES (l_user, SYSTIMESTAMP, l_ip, :G_OFFICE_ID, :P10_AUTH_METHOD, :G_USER_AGENT_ID);

    INSERT INTO REQUEST_LOG (USER_ID, DEVICE_IP, REQUEST_ACTION, REQUEST_DATE,
                             RESULT_STATUS, REQUEST_SOURCE, AUTH_METHOD)
    VALUES (l_user, l_ip, 'LOGIN', SYSTIMESTAMP,
            'SUCCESS', 'FORM', :P10_AUTH_METHOD);
  END IF;
END;
```

**Плюси:** ідеальна історія інтервалів, легко рахувати “хто був у системі в час T”, нормально перетинає північ.
**Мінуси:** потрібні правила для “завислих” сесій (див. авто‑закриття).

---

# Варіант C — Авто‑закриття/авто‑корекція “завислих” логінів

**Ідея:** якщо користувач забув вийти, не ламати наступний день.

## Політики:

1. **Idle timeout**: якщо сесія відкрита > N годин → авто‑logout з міткою причини.
2. **Rule on new login**: при новому `LOGIN`, якщо є відкрита — **закрити її** часом `LOGIN_DATE` нового входу минус ε або поточним часом (обрати політику).
3. **Shift‑aware**: якщо є таблиця `SHIFTS` з інтервалами, закривати відкриту сесію **в кінці попередньої зміни**.

## Приклад 2):

```plsql
-- Перед вставкою нового LOGIN:
UPDATE USER_SESSIONS
   SET LOGOUT_DATE = SYSTIMESTAMP,
       -- можна додати колонку REASON := 'AUTO_CLOSE_ON_NEW_LOGIN'
 WHERE USER_ID = l_user
   AND LOGOUT_DATE IS NULL;
```

**Плюси:** користувач ніколи не “залипає” назавжди → стабільний наступний логін.
**Мінуси:** автозакриття — це припущення; важливо погодити політику з бізнесом.

---

# Варіант D — Токен/квиток сесії (без плутанини з попередніми)

**Ідея:** при `LOGIN` видаємо `SESSION_TOKEN` (ID з таблиці). `LOGOUT` **вимагає** цей токен (наприклад, збережений у localStorage або прокидається з терміналу/NFC). Так не сплутаєш “старий” логін.

## Схема:

Додай `SESSION_TOKEN` (UUID) у `USER_SESSIONS`.
`LOGOUT` шукає саме цей токен:

```sql
UPDATE USER_SESSIONS
   SET LOGOUT_DATE = SYSTIMESTAMP
 WHERE SESSION_TOKEN = :token
   AND USER_ID = :user_id
   AND LOGOUT_DATE IS NULL;
```

**Плюси:** нуль двозначності, особливо при багатьох входах на різних ПК.
**Мінуси:** треба зберігати/передавати токен на клієнт.

---

# Варіант E — Подієва модель + reconcile job (максимальна гнучкість)

**Ідея:** записуємо *події* (`LOGIN`, `LOGOUT`) у `REQUEST_LOG` (з `AUTH_METHOD`, `DEVICE_IP`, `OFFICE_ID`), а далі **нічна/щогодинна задача** будує/коригує таблицю `USER_SESSIONS` з правил: “logout без login → ігнор/склеїти”, “login без logout → закрити о N годині”, “дублі → залишити найближчу пару” тощо.

**Плюси:** гнучкість, можна міняти правила ретроактивно.
**Мінуси:** звітність онлайн по інтервалах складніша (краще матеріалізований view або зведена `USER_SESSIONS`).

---

## Рекомендації, що б я обрав

* Для живої системи зі змінами/перетином півночі: **Варіант B** (+ невеличке **авто‑закриття** з C).
* Якщо робочі місця множаться/логін з різних ПК — унікальність відкритої сесії на `(USER_ID, DEVICE_IP)` і/або **SESSION\_TOKEN** (D).
* Паралельно завжди **аудит** у `REQUEST_LOG` з `AUTH_METHOD`, `RAW_INPUT`, `OFFICE_ID`, `USER_AGENT_ID`.

---

## Корисні шматки

### 1) View “хто в системі зараз”

```sql
CREATE OR REPLACE VIEW V_USERS_ONLINE AS
SELECT s.USER_ID, s.LOGIN_DATE, s.DEVICE_IP, s.OFFICE_ID
FROM   USER_SESSIONS s
WHERE  s.LOGOUT_DATE IS NULL;
```

### 2) “Хто був у проміжку \[t1, t2]” (перетин інтервалів)

```sql
SELECT USER_ID, LOGIN_DATE, LOGOUT_DATE
FROM   USER_SESSIONS
WHERE  LOGIN_DATE < :t2
  AND  NVL(LOGOUT_DATE, SYSTIMESTAMP) > :t1;
```

### 3) Розбиття сесій по днях (репорти за датами/змінами)

```sql
-- приклад: кількість хвилин у кожному дні для сесії, що перетинає доби
-- (можна реалізувати у пізнішому звіті/матв'ю)
```

### 4) Ідемпотентність “подій” (захист від повтору кліка/скану)

Додай хеш події:

```sql
ALTER TABLE REQUEST_LOG ADD REQUEST_HASH VARCHAR2(64);
CREATE UNIQUE INDEX UQ_REQLOG_HASH ON REQUEST_LOG (REQUEST_HASH);

-- При вставці:
-- REQUEST_HASH := STANDARD_HASH(USER_ID||REQUEST_ACTION||TO_CHAR(SYSTIMESTAMP,'YYYYMMDDHH24MI'), 'SHA1');
```

Це прибере випадкові дублі в хвилинному вікні (налаштовується).

---

## Підсумок

* **Не** рахуємо парність.
* Тримаємо **стан або сесію** в окремій таблиці з **рядковими локами**/унікальними індексами.
* Додаємо **авто‑правила** для зависань (timeout / авто‑закриття на новий login / кінець зміни).
* Обов’язково лог — `REQUEST_LOG` з `AUTH_METHOD`, `OFFICE_ID`, `USER_AGENT_ID`, `DEVICE_IP`.
* За потреби — **SESSION\_TOKEN**, щоб logout закривав саме той вхід.

Якщо скажеш, які з цих правил для вас бізнесово правильні (часи зміни, дозволяти/забороняти паралельні входи, timeout у годинах), я піджену точні DDL/процеси APEX під ваш сценарій.
