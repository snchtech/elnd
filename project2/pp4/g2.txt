Коротко:

**“Підрахунок парних”** = наївно беремо кількість подій `LOGIN/LOGOUT` в журналі й вважаємо, що парна → “поза системою”, непарна → “в системі”.
**“Таблиця сесій (варіант B)”** = кожен логін — це рядок (сесія) з `LOGIN_DATE`; вихід — заповнення `LOGOUT_DATE`. Поточний стан — це **наявність відкритої сесії** (`LOGOUT_DATE IS NULL`). Журнал подій не потрібен для визначення стану — лише для аудиту.

---

## Чим саме відрізняються

| Критерій                           | Підрахунок парних                     | Таблиця сесій (B)                                                  |
| ---------------------------------- | ------------------------------------- | ------------------------------------------------------------------ |
| Залежність від “ідеальних” пар     | Висока (будь‑який пропуск ламає стан) | Немає (стан = “є/нема відкритого рядка”)                           |
| Перехід через північ               | Ламає підрахунок по днях              | Неважливо: інтервал `LOGIN_DATE..LOGOUT_DATE` може перетинати дати |
| Дублікати/подвійні кліки           | Ламають парність                      | Не впливають, якщо є унікальність “лише одна відкрита”             |
| Онлайн‑запит “хто в системі зараз” | Важко/неточно                         | Простий `WHERE LOGOUT_DATE IS NULL`                                |
| Рахунок відпрацьованого часу       | Складно (потрібно парити вручну)      | Легко (інтервали сесій)                                            |

---

## Сценарій: користувач не зробив LOGOUT і наступного дня тисне LOGIN

У **таблиці сесій** ви керуєте цим **правилом**. Є три типові політики (оберіть одну):

### A) Авто‑закрити відкриту сесію й створити нову (найзручніше)

* Гарантія: “відкрита не висітиме вічно”, наступний `LOGIN` **не зламає стан**.
* Реалізація (у процесі LOGIN перед вставкою нової сесії):

```plsql
-- 1) Закриваємо, якщо щось відкрите
UPDATE user_sessions
   SET logout_date = SYSTIMESTAMP
 WHERE user_id = :l_user_id
   AND logout_date IS NULL;

-- 2) Створюємо нову сесію
INSERT INTO user_sessions (user_id, login_date, device_ip, office_id, auth_method, user_agent_id)
VALUES (:l_user_id, SYSTIMESTAMP, :l_ip, :l_office_id, :l_auth, :l_ua_id);
```

> Щоб гарантовано не було 2 “відкритих” — унікальний індекс:

```sql
CREATE UNIQUE INDEX ux_user_open_session
  ON user_sessions (user_id, NVL(logout_date, DATE '4712-12-31'));
```

**Що відбудеться завтра, якщо вчора не вийшов?**
Пункт 1 закриє вчорашню сесію поточним часом; потім створиться нова сесія — все коректно.

---

### B) Заборонити новий LOGIN, поки є відкрита сесія

* Строгіше правило — змушує користувача натиснути LOGOUT.
* Реалізація:

```plsql
SELECT 1
  INTO :dummy
  FROM user_sessions
 WHERE user_id = :l_user_id
   AND logout_date IS NULL;
-- якщо знайшли → показати помилку: "Спершу виконайте вихід"
```

**Мінус:** якщо користувач забув учора — сьогодні не зможе зайти, поки хтось не закриє сесію вручну/авто.

---

### C) Авто‑закриття за таймаутом/кінець зміни (доповнення до A/B)

* Напр., раз на годину job:

```plsql
UPDATE user_sessions
   SET logout_date = SYSTIMESTAMP /* або кінець попередньої зміни */
 WHERE logout_date IS NULL
   AND login_date < SYSTIMESTAMP - INTERVAL '12' HOUR;
```

* Або “при новому login закрий усі старші за N годин”.

---

## Чому “парні” ламаються саме у вашому кейсі

* Учора: `LOGIN` (без `LOGOUT`) → **непарна** кількість.
* Сьогодні перша подія — “LOGIN” → тепер **парна**. Парність каже: “користувач **поза** системою”, хоча він **щойно увійшов** — **помилка моделі**.

У варіанті B такого немає:

* Учорашній `LOGOUT_DATE IS NULL` → “у системі”.
* Сьогодні натиснув “LOGIN”: або автоматично закрили попередню й відкрили нову (A), або відмовили (B). У будь‑якому разі — **однозначний стан**.

---

## Міні‑приклад таймлайна (політика A)

* 2025‑08‑12 22:00 — `LOGIN` → рядок #101: `LOGIN_DATE=22:00`, `LOGOUT_DATE=NULL`.
* 2025‑08‑13 08:15 — знов `LOGIN`:

  * спершу: закрили #101 з `LOGOUT_DATE=08:15`;
  * потім: створили #202: `LOGIN_DATE=08:15`, `LOGOUT_DATE=NULL`.
* Звіт “хто в системі о 07:30 2025‑08‑13” → бачить #101 (перетин інтервалу).
* “Хто о 09:00” → бачить #202. Все коректно, незважаючи на північ.

---

## Підсумкова рекомендація

1. Вводьте **таблицю сесій** з унікальністю *“одна відкрита на користувача”* (або на користувача+пристрій).
2. Оберіть політику:

   * **A (рекомендовано):** авто‑закривати відкриту при новому login → стабільно і просто для користувача.
   * **B:** не дозволяти новий login, поки є відкрита → дисциплінує, але жорстко.
   * **C:** додайте таймаути/кінець зміни як страховку.
3. Продовжуйте писати **аудит** у `REQUEST_LOG` (подія + метод `AUTH_METHOD` + `DEVICE_IP` + `OFFICE_ID`).

Якщо скажеш, яку політику берете (A/B/C) і чи дозволені паралельні входи з різних ПК, накину точний PL/SQL для вашого процесу APEX (LOGIN/LOGOUT/OK) під обрану модель.
