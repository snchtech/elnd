Нижче — готовий “best‑practice” варіант із **таблицею сесій** (без дублювання даних із `REQUEST_LOG`), оновленням `REQUEST_LOG` (зв’язок на сесію), та **одним AJAX‑процесом** для обробки логіки “немає сесії → створити”, “є сесія → запропонувати Вийти/Новий вхід”, причому для **“Новий вхід”** закриваємо минулу сесію з `logout_date = login_date` (нульова тривалість), як ти й просив.

---

# 1) Таблиця сесій (DDL)

```sql
-- 12c+: IDENTITY (для 11g зробиш sequence+trigger)
CREATE TABLE USER_SESSIONS (
  ID             NUMBER GENERATED BY DEFAULT AS IDENTITY
                   CONSTRAINT PK_USER_SESSIONS PRIMARY KEY,
  USER_ID        NUMBER      NOT NULL,
  LOGIN_DATE     TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
  LOGOUT_DATE    TIMESTAMP WITH TIME ZONE,
  LAST_SEEN      TIMESTAMP WITH TIME ZONE,           -- (опц.) heartbeat/активність
  DEVICE_IP      VARCHAR2(45),
  OFFICE_ID      NUMBER,
  AUTH_METHOD    VARCHAR2(10)                         -- 'MANUAL' | 'NFC'
                   CONSTRAINT CK_SESS_AUTH CHECK (AUTH_METHOD IN ('MANUAL','NFC')),
  USER_AGENT_ID  NUMBER,                              -- нормалізований UA (з твого довідника)
  CLOSE_REASON   VARCHAR2(30)                         -- 'MANUAL' | 'FORCED_NEW_LOGIN' | 'AUTO_IDLE'
);

-- 1 відкрита сесія на користувача (страховка від гонок)
CREATE UNIQUE INDEX UX_USER_OPEN_SESSION
  ON USER_SESSIONS (USER_ID, NVL(LOGOUT_DATE, DATE '4712-12-31'));

-- Типові індекси для звітів
CREATE INDEX IX_SESS_USER_LOGIN ON USER_SESSIONS (USER_ID, LOGIN_DATE);
CREATE INDEX IX_SESS_LOGIN      ON USER_SESSIONS (LOGIN_DATE);
CREATE INDEX IX_SESS_OFFICE     ON USER_SESSIONS (OFFICE_ID);
```

> `LAST_SEEN` і `CLOSE_REASON` допомагають в аналітиці, але якщо хочеш мінімум — можеш їх опустити.

---

# 2) Оновлення `REQUEST_LOG`: зв’язок із сесією (без дублю)

`REQUEST_LOG` лишаємо як **аудит подій**, але не зберігаємо там часові інтервали. Додаємо посилання на сесію:

```sql
ALTER TABLE REQUEST_LOG ADD SESSION_ROW_ID NUMBER;

-- опціонально: якщо все в одній схемі — робимо FK
ALTER TABLE REQUEST_LOG
  ADD CONSTRAINT FK_REQLOG_SESSION
  FOREIGN KEY (SESSION_ROW_ID) REFERENCES USER_SESSIONS(ID);
```

> Надалі, коли створюєш/закриваєш сесію, пишеш 1 рядок у `REQUEST_LOG` з `REQUEST_ACTION='LOGIN'` або `'LOGOUT'` і підставляєш `SESSION_ROW_ID`. Жодних дублювань часу — інтервали лише в `USER_SESSIONS`.

---

# 3) Єдиний AJAX‑процес для NFC/ручного вводу

Маємо однакову логіку для **NFC і ручного вводу**. Клієнт передає в `x01` дію:

* `x01 = 'AUTO'` — первинний виклик (користувач приклав мітку/ввів код, ми вирішуємо, що показати: одразу логін або діалог з вибором).
* `x01 = 'LOGOUT'` — користувач у діалозі натиснув “Вийти”.
* `x01 = 'NEW'` — натиснув “Новий вхід” → закриваємо попередню нульовою тривалістю і створюємо нову.

```plsql
DECLARE
  l_code      VARCHAR2(400) := :P10_CODE; -- може бути NFC або ID
  l_user_id   USERS.USER_ID%TYPE;
  l_method    VARCHAR2(10);               -- 'MANUAL' | 'NFC'
  l_ip        VARCHAR2(45)  := util_net.get_client_ip;
  l_ua_id     NUMBER        := :G_USER_AGENT_ID;  -- з твоєї нормалізації UA
  l_office_id NUMBER        := :G_OFFICE_ID;      -- з Page 0
  l_now       TIMESTAMP WITH TIME ZONE := SYSTIMESTAMP;
  l_open_id   NUMBER;     -- відкрита сесія (якщо є)
  l_login_dt  TIMESTAMP WITH TIME ZONE;
  l_action    VARCHAR2(10) := NVL(apex_application.g_x01, 'AUTO'); -- 'AUTO' | 'LOGOUT' | 'NEW'

  PROCEDURE log_event(p_user_id NUMBER, p_session_id NUMBER, p_action VARCHAR2,
                      p_result VARCHAR2, p_err VARCHAR2 DEFAULT NULL) IS
  BEGIN
    INSERT INTO REQUEST_LOG (
      USER_ID, DEVICE_IP, REQUEST_ACTION, REQUEST_DATE,
      SESSION_ID, REQUEST_SOURCE, RESULT_STATUS, AUTH_METHOD,
      USER_AGENT_ID, SESSION_ROW_ID, ERROR_MESSAGE
    ) VALUES (
      p_user_id, l_ip, p_action, l_now,
      v('APP_SESSION'), 'FORM', p_result, l_method,
      l_ua_id, p_session_id, p_err
    );
  END;
BEGIN
  apex_json.open_object;

  -- 1) Визначаємо користувача (NFC має пріоритет)
  BEGIN
    WITH indata AS (
      SELECT l_code AS code, norm_nfc(l_code) AS code_nfc FROM dual
    )
    SELECT user_id, method
      INTO l_user_id, l_method
      FROM (
        SELECT n.user_id, 'NFC' AS method, 1 AS ord
          FROM user_nfc n JOIN indata d ON n.nfc_id = d.code_nfc
        UNION ALL
        SELECT u.user_id, 'MANUAL' AS method, 2 AS ord
          FROM users u JOIN indata d
            ON REGEXP_LIKE(d.code,'^\d+$') AND u.user_id = TO_NUMBER(d.code)
      )
      ORDER BY ord
      FETCH FIRST 1 ROW ONLY;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    l_user_id := NULL;
  END;

  IF l_user_id IS NULL THEN
    apex_json.write('ok', false);
    apex_json.write('message', 'Користувача не знайдено.');
    apex_json.close_object;
    RETURN;
  END IF;

  -- 2) Чи є відкрита сесія?
  BEGIN
    SELECT id, login_date
      INTO l_open_id, l_login_dt
      FROM user_sessions
     WHERE user_id = l_user_id
       AND logout_date IS NULL
       FOR UPDATE;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    l_open_id := NULL;
  END;

  -- 3) Режими
  IF l_action = 'AUTO' THEN
    IF l_open_id IS NULL THEN
      -- Нема сесії -> одразу логін
      INSERT INTO user_sessions (user_id, login_date, last_seen,
                                 device_ip, office_id, auth_method, user_agent_id)
      VALUES (l_user_id, l_now, l_now, l_ip, l_office_id, l_method, l_ua_id)
      RETURNING id INTO l_open_id;

      log_event(l_user_id, l_open_id, 'LOGIN', 'SUCCESS');

      apex_json.write('ok', true);
      apex_json.write('mode', 'LOGIN_DONE');
      apex_json.write('sessionId', l_open_id);
      apex_json.write('loginTs', TO_CHAR(l_now AT LOCAL TIME ZONE, 'dd.mm.yyyy hh24:mi'));
      -- додай інші дані для твоєї картки
    ELSE
      -- Є відкрита -> показуємо діалог "Вийти або Новий вхід"
      apex_json.write('ok', true);
      apex_json.write('mode', 'HAS_OPEN_SESSION');
      apex_json.write('sessionId', l_open_id);
      apex_json.write('openLoginTs', TO_CHAR(l_login_dt AT LOCAL TIME ZONE, 'dd.mm.yyyy hh24:mi'));
    END IF;

  ELSIF l_action = 'LOGOUT' THEN
    -- Закриваємо відкриту сесію (якщо немає -> помилка UI)
    IF l_open_id IS NULL THEN
      -- на всяк випадок перевіримо ще раз без блокування
      SELECT id INTO l_open_id FROM (
        SELECT id FROM user_sessions WHERE user_id = l_user_id AND logout_date IS NULL
      ) WHERE ROWNUM = 1;
    END IF;

    UPDATE user_sessions
       SET logout_date = l_now,
           close_reason = 'MANUAL'
     WHERE id = l_open_id;

    log_event(l_user_id, l_open_id, 'LOGOUT', 'SUCCESS');

    apex_json.write('ok', true);
    apex_json.write('mode', 'LOGOUT_DONE');
    apex_json.write('sessionId', l_open_id);
    apex_json.write('logoutTs', TO_CHAR(l_now AT LOCAL TIME ZONE, 'dd.mm.yyyy hh24:mi'));

  ELSIF l_action = 'NEW' THEN
    -- Спершу форс‑закриваємо минулу нульовою тривалістю: logout = login
    IF l_open_id IS NULL THEN
      SELECT id, login_date
        INTO l_open_id, l_login_dt
        FROM (
          SELECT id, login_date
          FROM user_sessions
          WHERE user_id = l_user_id
          ORDER BY login_date DESC
        ) WHERE ROWNUM = 1
        FOR UPDATE;
    END IF;

    UPDATE user_sessions
       SET logout_date = login_date,
           close_reason = 'FORCED_NEW_LOGIN'
     WHERE id = l_open_id;

    log_event(l_user_id, l_open_id, 'LOGOUT', 'SUCCESS');

    -- Створюємо нову сесію
    INSERT INTO user_sessions (user_id, login_date, last_seen,
                               device_ip, office_id, auth_method, user_agent_id)
    VALUES (l_user_id, l_now, l_now, l_ip, l_office_id, l_method, l_ua_id)
    RETURNING id INTO l_open_id;

    log_event(l_user_id, l_open_id, 'LOGIN', 'SUCCESS');

    apex_json.write('ok', true);
    apex_json.write('mode', 'NEW_LOGIN_DONE');
    apex_json.write('sessionId', l_open_id);
    apex_json.write('loginTs', TO_CHAR(l_now AT LOCAL TIME ZONE, 'dd.mm.yyyy hh24:mi'));
  END IF;

  apex_json.close_object;

EXCEPTION
  WHEN OTHERS THEN
    -- Зафіксуємо помилку, без дублю інтервалів (сесія може бути NULL)
    log_event(l_user_id, l_open_id, NVL(l_action, 'AUTO'), 'FAIL', SUBSTR(SQLERRM,1,4000));

    apex_json.open_object;
    apex_json.write('ok', false);
    apex_json.write('message', 'Системна помилка. Спробуйте ще раз.');
    apex_json.close_object;
END;
```

### Як це працює з інтерфейсом

* Коли користувач сканує/вводить код — виклик з `x01='AUTO'`.

  * Якщо сесії нема → одразу логін (повертаємо `mode='LOGIN_DONE'`).
  * Якщо сесія є → повертаємо `mode='HAS_OPEN_SESSION'` і показуємо діалог з кнопками **Вийти** / **Новий вхід**.
* Натискання кнопок шле другий виклик з `x01='LOGOUT'` або `x01='NEW'`.

> **Зверни увагу:** в `REQUEST_LOG` ми пишемо **одну подію на дію** й завжди з `SESSION_ROW_ID`. Усі часові інтервали живуть тільки в `USER_SESSIONS`.

---

# 4) Звіт/вивід “USER\_ID, login, logout, …”

## Базовий view для звітів

```sql
CREATE OR REPLACE VIEW V_USER_ATTENDANCE AS
SELECT
  s.ID                AS SESSION_ID,
  s.USER_ID,
  u.USER_FIRSTNAME,
  u.USER_LASTNAME,
  s.LOGIN_DATE,
  s.LOGOUT_DATE,
  s.CLOSE_REASON,
  s.DEVICE_IP,
  s.OFFICE_ID,
  s.AUTH_METHOD,
  s.USER_AGENT_ID
FROM USER_SESSIONS s
LEFT JOIN USERS u ON u.USER_ID = s.USER_ID;
```

**Приклади запитів:**

```sql
-- Список сесій користувача
SELECT USER_ID, LOGIN_DATE, LOGOUT_DATE, CLOSE_REASON
FROM   V_USER_ATTENDANCE
WHERE  USER_ID = :p_user
ORDER  BY LOGIN_DATE DESC;

-- Хто "в системі" зараз (логічно: відкрита сесія)
SELECT USER_ID, LOGIN_DATE
FROM   USER_SESSIONS
WHERE  LOGOUT_DATE IS NULL;

-- Інтервали, що перетинають день D
SELECT USER_ID, LOGIN_DATE, LOGOUT_DATE, CLOSE_REASON
FROM   USER_SESSIONS
WHERE  LOGIN_DATE < :D + 1
  AND  NVL(LOGOUT_DATE, SYSTIMESTAMP) >= :D;

-- Проблемні (FORCED_NEW_LOGIN або нульові тривалості)
SELECT USER_ID, LOGIN_DATE, LOGOUT_DATE
FROM   USER_SESSIONS
WHERE  CLOSE_REASON = 'FORCED_NEW_LOGIN'
   OR  LOGOUT_DATE = LOGIN_DATE;
```

---

# 5) Підсумок архітектури

* **USER\_SESSIONS** — єдине джерело правди для інтервалів `login/logout`.
* **REQUEST\_LOG** — аудиторський трек подій (LOGIN/LOGOUT/ERROR) із посиланням `SESSION_ROW_ID` (без дублю дат інтервалів).
* **“Новий вхід”** → минулу сесію закриваємо `logout_date = login_date` + `close_reason='FORCED_NEW_LOGIN'`, потім створюємо нову.
* Через view/запити легко діставати “USER\_ID, login time, logout time, …”.

Хочеш — можу додати короткі JS‑шматки для показу діалогу “Є відкрита сесія → Вийти / Новий вхід” і як викликати цей процес із `x01`.
