Клас! Переробляємо на “сесії + довідники” без дублю даних і без “магічних рядків”.

---

# 1) DDL: довідники + мінімалістична таблиця сесій

## 1.1 Довідники

```sql
-- Явні ID, щоб зручно лінкуватись (можеш використати IDENTITY/SEQ)
CREATE TABLE AUTH_METHOD_LU (            -- як користувач ідентифікований
  ID   NUMBER PRIMARY KEY,
  CODE VARCHAR2(20) UNIQUE NOT NULL      -- 'MANUAL' | 'NFC'
);
INSERT INTO AUTH_METHOD_LU(ID,CODE) VALUES (1,'MANUAL');
INSERT INTO AUTH_METHOD_LU(ID,CODE) VALUES (2,'NFC');

CREATE TABLE ACTION_TYPE_LU (            -- що робимо в логах
  ID   NUMBER PRIMARY KEY,
  CODE VARCHAR2(20) UNIQUE NOT NULL      -- 'LOGIN' | 'LOGOUT' | 'CHECK'
);
INSERT INTO ACTION_TYPE_LU VALUES (1,'LOGIN');
INSERT INTO ACTION_TYPE_LU VALUES (2,'LOGOUT');
INSERT INTO ACTION_TYPE_LU VALUES (3,'CHECK');

CREATE TABLE RESULT_STATUS_LU (          -- результат події
  ID   NUMBER PRIMARY KEY,
  CODE VARCHAR2(20) UNIQUE NOT NULL      -- 'SUCCESS' | 'FAIL'
);
INSERT INTO RESULT_STATUS_LU VALUES (1,'SUCCESS');
INSERT INTO RESULT_STATUS_LU VALUES (2,'FAIL');

CREATE TABLE CLOSE_REASON_LU (           -- як закрита сесія
  ID   NUMBER PRIMARY KEY,
  CODE VARCHAR2(30) UNIQUE NOT NULL,     -- 'MANUAL' | 'FORCED_NEW_LOGIN' | 'AUTO_IDLE'
  NAME VARCHAR2(100)
);
INSERT INTO CLOSE_REASON_LU VALUES (1,'MANUAL','Closed by user');
INSERT INTO CLOSE_REASON_LU VALUES (2,'FORCED_NEW_LOGIN','Forced by New login');
INSERT INTO CLOSE_REASON_LU VALUES (3,'AUTO_IDLE','Closed by idle policy');
```

## 1.2 USER\_SESSIONS — без дублюючих полів

```sql
CREATE TABLE USER_SESSIONS (
  ID             NUMBER GENERATED BY DEFAULT AS IDENTITY
                   CONSTRAINT PK_USER_SESSIONS PRIMARY KEY,
  USER_ID        NUMBER      NOT NULL,
  LOGIN_DATE     TIMESTAMP WITH TIME ZONE DEFAULT SYSTIMESTAMP NOT NULL,
  LOGOUT_DATE    TIMESTAMP WITH TIME ZONE,
  CLOSE_REASON_ID NUMBER     REFERENCES CLOSE_REASON_LU(ID)  -- NULL для відкритої
);

-- гарантія: лише 1 відкрита сесія на користувача
CREATE UNIQUE INDEX UX_USER_OPEN_SESSION
  ON USER_SESSIONS (USER_ID, NVL(LOGOUT_DATE, DATE '4712-12-31'));

CREATE INDEX IX_SESS_USER_LOGIN ON USER_SESSIONS (USER_ID, LOGIN_DATE);
```

> Поля `DEVICE_IP`, `OFFICE_ID`, `AUTH_METHOD`, `USER_AGENT_ID` залишаємо **в `REQUEST_LOG`**, бо це подієві атрибути (джерело, спосіб ідентифікації, середовище). У сесіях тримаємо **тільки інтервал** + причину закриття.

## 1.3 REQUEST\_LOG — зв’язуємо з довідниками (без рядків)

```sql
ALTER TABLE REQUEST_LOG ADD (
  ACTION_TYPE_ID    NUMBER REFERENCES ACTION_TYPE_LU(ID),
  RESULT_STATUS_ID  NUMBER REFERENCES RESULT_STATUS_LU(ID),
  AUTH_METHOD_ID    NUMBER REFERENCES AUTH_METHOD_LU(ID),
  SESSION_ROW_ID    NUMBER REFERENCES USER_SESSIONS(ID)
);

-- (опційно) після міграції можна видалити старі текстові колонки:
-- ALTER TABLE REQUEST_LOG DROP COLUMN REQUEST_ACTION;
-- ALTER TABLE REQUEST_LOG DROP COLUMN RESULT_STATUS;
-- ALTER TABLE REQUEST_LOG DROP COLUMN AUTH_METHOD;
```

---

# 2) Сервісні функції для lookup (щоб не “хардкодити” ID)

```sql
CREATE OR REPLACE PACKAGE lu AS
  FUNCTION action_id(p_code VARCHAR2) RETURN NUMBER;        -- 'LOGIN', 'LOGOUT', 'CHECK'
  FUNCTION result_id(p_code VARCHAR2) RETURN NUMBER;        -- 'SUCCESS', 'FAIL'
  FUNCTION auth_id  (p_code VARCHAR2) RETURN NUMBER;        -- 'MANUAL', 'NFC'
  FUNCTION close_id (p_code VARCHAR2) RETURN NUMBER;        -- 'MANUAL', 'FORCED_NEW_LOGIN', 'AUTO_IDLE'
END lu;
/

CREATE OR REPLACE PACKAGE BODY lu AS
  FUNCTION action_id(p_code VARCHAR2) RETURN NUMBER IS r NUMBER; BEGIN
    SELECT id INTO r FROM action_type_lu WHERE code = p_code; RETURN r; END;
  FUNCTION result_id(p_code VARCHAR2) RETURN NUMBER IS r NUMBER; BEGIN
    SELECT id INTO r FROM result_status_lu WHERE code = p_code; RETURN r; END;
  FUNCTION auth_id(p_code VARCHAR2)   RETURN NUMBER IS r NUMBER; BEGIN
    SELECT id INTO r FROM auth_method_lu WHERE code = p_code; RETURN r; END;
  FUNCTION close_id(p_code VARCHAR2)  RETURN NUMBER IS r NUMBER; BEGIN
    SELECT id INTO r FROM close_reason_lu WHERE code = p_code; RETURN r; END;
END lu;
/
```

---

# 3) “Операції” з клієнта (x01) — теж без рядків

Щоб не передавати `'AUTO'/'LOGOUT'/'NEW'`, вводимо маленький довідник **операцій UI**:

```sql
-- Можеш не робити таблицю, достатньо домовленості про коди:
-- 1=AUTO, 2=LOGOUT, 3=NEW
```

У JS:

```js
const OP = { AUTO:1, LOGOUT:2, NEW:3 };

// приклад виклику:
apex.server.process("SESS_PROC",
  { x01: OP.AUTO, pageItems: "#P10_CODE" },
  { dataType:"json", success:function(res){ /* ... */ } }
);
```

---

# 4) AJAX‑процес (оновлений, нормалізований)

* Логіка NFC/ручного вводу така ж (пріоритет NFC).
* Ніяких текстів у БД — тільки ID довідників.
* “Новий вхід” закриває попередню сесію з `LOGOUT_DATE = LOGIN_DATE` + `CLOSE_REASON_ID = lu.close_id('FORCED_NEW_LOGIN')`.

```plsql
DECLARE
  l_code      VARCHAR2(400) := :P10_CODE;
  l_user_id   USERS.USER_ID%TYPE;
  l_auth_id   NUMBER;                                -- 1=MANUAL, 2=NFC
  l_ip        VARCHAR2(45)  := util_net.get_client_ip;
  l_ua_id     NUMBER        := :G_USER_AGENT_ID;     -- з твоєї нормалізації UA
  l_office_id NUMBER        := :G_OFFICE_ID;         -- якщо логиш у REQUEST_LOG
  l_now       TIMESTAMP WITH TIME ZONE := SYSTIMESTAMP;

  l_open_id   NUMBER;
  l_login_dt  TIMESTAMP WITH TIME ZONE;

  -- оп код з клієнта: 1=AUTO, 2=LOGOUT, 3=NEW
  l_op        PLS_INTEGER := NVL(apex_application.g_x01, 1);

  PROCEDURE put_log(p_user_id NUMBER, p_sess_id NUMBER,
                    p_action_code VARCHAR2, p_result_code VARCHAR2, p_err VARCHAR2 DEFAULT NULL) IS
  BEGIN
    INSERT INTO REQUEST_LOG(
      USER_ID, DEVICE_IP, REQUEST_DATE, SESSION_ID, REQUEST_SOURCE,
      ACTION_TYPE_ID, RESULT_STATUS_ID, AUTH_METHOD_ID,
      USER_AGENT_ID, SESSION_ROW_ID, ERROR_MESSAGE
    ) VALUES (
      p_user_id, l_ip, l_now, v('APP_SESSION'), 'FORM',
      lu.action_id(p_action_code), lu.result_id(p_result_code), l_auth_id,
      l_ua_id, p_sess_id, p_err
    );
  END;
BEGIN
  apex_json.open_object;

  -- 1) Хто користувач і який метод (NFC/Manual)
  BEGIN
    WITH indata AS ( SELECT l_code code, norm_nfc(l_code) code_nfc FROM dual )
    SELECT user_id, method
      INTO l_user_id, /* 'NFC'/'MANUAL' */ l_code
      FROM (
        SELECT n.user_id, 'NFC' AS method, 1 ord FROM user_nfc n JOIN indata d ON n.nfc_id = d.code_nfc
        UNION ALL
        SELECT u.user_id, 'MANUAL' AS method, 2 ord
          FROM users u JOIN indata d ON REGEXP_LIKE(d.code,'^\d+$') AND u.user_id = TO_NUMBER(d.code)
      )
      ORDER BY ord FETCH FIRST 1 ROW ONLY;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    apex_json.write('ok', false);
    apex_json.write('message', 'Користувача не знайдено.');
    apex_json.close_object;
    RETURN;
  END;

  l_auth_id := lu.auth_id(CASE WHEN l_code='NFC' THEN 'NFC' ELSE 'MANUAL' END);

  -- 2) Чи є відкрита сесія?
  BEGIN
    SELECT id, login_date
      INTO l_open_id, l_login_dt
      FROM user_sessions
     WHERE user_id = l_user_id
       AND logout_date IS NULL
       FOR UPDATE;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    l_open_id := NULL;
  END;

  -- 3) Маршрутизація
  IF l_op = 1 /* AUTO */ THEN
    IF l_open_id IS NULL THEN
      -- одразу LOGIN
      INSERT INTO user_sessions (user_id, login_date) VALUES (l_user_id, l_now)
      RETURNING id INTO l_open_id;

      put_log(l_user_id, l_open_id, 'LOGIN', 'SUCCESS');

      apex_json.write('ok', true);
      apex_json.write('mode_id', 1); -- LOGIN_DONE
      apex_json.write('sessionId', l_open_id);
      apex_json.write('loginTs', TO_CHAR(l_now AT LOCAL TIME ZONE, 'dd.mm.yyyy hh24:mi'));
    ELSE
      -- є відкрита -> показуємо діалог
      apex_json.write('ok', true);
      apex_json.write('mode_id', 2); -- HAS_OPEN_SESSION
      apex_json.write('sessionId', l_open_id);
      apex_json.write('openLoginTs', TO_CHAR(l_login_dt AT LOCAL TIME ZONE, 'dd.mm.yyyy hh24:mi'));
    END IF;

  ELSIF l_op = 2 /* LOGOUT */ THEN
    -- закрити вручну
    IF l_open_id IS NOT NULL THEN
      UPDATE user_sessions
         SET logout_date = l_now,
             close_reason_id = lu.close_id('MANUAL')
       WHERE id = l_open_id;
      put_log(l_user_id, l_open_id, 'LOGOUT', 'SUCCESS');

      apex_json.write('ok', true);
      apex_json.write('mode_id', 3); -- LOGOUT_DONE
      apex_json.write('sessionId', l_open_id);
      apex_json.write('logoutTs', TO_CHAR(l_now AT LOCAL TIME ZONE, 'dd.mm.yyyy hh24:mi'));
    ELSE
      apex_json.write('ok', false);
      apex_json.write('message', 'Відкрита сесія не знайдена.');
    END IF;

  ELSIF l_op = 3 /* NEW */ THEN
    -- форс-закриття попередньої 0-тривалістю, потім новий логін
    IF l_open_id IS NULL THEN
      -- на випадок гонок: беремо останню сесію
      SELECT id, login_date
        INTO l_open_id, l_login_dt
        FROM (
          SELECT id, login_date
          FROM user_sessions
          WHERE user_id = l_user_id
          ORDER BY login_date DESC
        ) WHERE ROWNUM = 1
        FOR UPDATE;
    END IF;

    UPDATE user_sessions
       SET logout_date = login_date,
           close_reason_id = lu.close_id('FORCED_NEW_LOGIN')
     WHERE id = l_open_id;

    put_log(l_user_id, l_open_id, 'LOGOUT', 'SUCCESS');

    INSERT INTO user_sessions (user_id, login_date) VALUES (l_user_id, l_now)
    RETURNING id INTO l_open_id;

    put_log(l_user_id, l_open_id, 'LOGIN', 'SUCCESS');

    apex_json.write('ok', true);
    apex_json.write('mode_id', 4); -- NEW_LOGIN_DONE
    apex_json.write('sessionId', l_open_id);
    apex_json.write('loginTs', TO_CHAR(l_now AT LOCAL TIME ZONE, 'dd.mm.yyyy hh24:mi'));
  END IF;

  apex_json.close_object;

EXCEPTION
  WHEN OTHERS THEN
    -- мінімальне логування помилки (без дублів інтервалів)
    BEGIN put_log(l_user_id, l_open_id, 'CHECK', 'FAIL', SUBSTR(SQLERRM,1,4000)); EXCEPTION WHEN OTHERS THEN NULL; END;
    apex_json.open_object;
    apex_json.write('ok', false);
    apex_json.write('message', 'Системна помилка. Спробуйте ще раз.');
    apex_json.close_object;
END;
```

> Зверни увагу: у `REQUEST_LOG` ми більше **не пишемо рядки** `'LOGIN'/'SUCCESS'/'NFC'` — лише ID з довідників.

---

# 5) Як передавати оп‑коди з JS (без рядків)

```js
const OP = { AUTO:1, LOGOUT:2, NEW:3 };

function submitAuto(){
  apex.server.process("SESS_PROC", { x01: OP.AUTO, pageItems: "#P10_CODE" }, { success: handleResp });
}
function doLogout(){
  apex.server.process("SESS_PROC", { x01: OP.LOGOUT, pageItems: "#P10_CODE" }, { success: handleResp });
}
function doNew(){
  apex.server.process("SESS_PROC", { x01: OP.NEW, pageItems: "#P10_CODE" }, { success: handleResp });
}
```

На відповіді `mode_id` теж числовий (1=LOGIN\_DONE, 2=HAS\_OPEN\_SESSION, 3=LOGOUT\_DONE, 4=NEW\_LOGIN\_DONE) — зручно для UI‑світчів.

---

# 6) View для звітів (читабельно, але на зберіганні — лише ID)

```sql
CREATE OR REPLACE VIEW V_USER_ATTENDANCE AS
SELECT
  s.ID            AS SESSION_ID,
  s.USER_ID,
  u.USER_FIRSTNAME,
  u.USER_LASTNAME,
  s.LOGIN_DATE,
  s.LOGOUT_DATE,
  cr.CODE         AS CLOSE_REASON_CODE,
  cr.NAME         AS CLOSE_REASON_NAME
FROM USER_SESSIONS s
LEFT JOIN USERS u        ON u.USER_ID = s.USER_ID
LEFT JOIN CLOSE_REASON_LU cr ON cr.ID = s.CLOSE_REASON_ID;
```

(опц.) Зручний в’юшка по логам:

```sql
CREATE OR REPLACE VIEW V_REQUEST_LOG AS
SELECT
  r.ID, r.USER_ID, r.REQUEST_DATE, r.SESSION_ROW_ID,
  at.CODE AS ACTION_CODE, rs.CODE AS RESULT_CODE, am.CODE AS AUTH_METHOD_CODE,
  r.DEVICE_IP, r.SESSION_ID, r.REQUEST_SOURCE, r.ERROR_CODE, r.ERROR_MESSAGE
FROM REQUEST_LOG r
LEFT JOIN ACTION_TYPE_LU   at ON at.ID = r.ACTION_TYPE_ID
LEFT JOIN RESULT_STATUS_LU rs ON rs.ID = r.RESULT_STATUS_ID
LEFT JOIN AUTH_METHOD_LU   am ON am.ID = r.AUTH_METHOD_ID;
```

---

## Підсумок

* **USER\_SESSIONS**: тільки `USER_ID`, `LOGIN_DATE`, `LOGOUT_DATE`, `CLOSE_REASON_ID`. Жодних дублюючих полів.
* **REQUEST\_LOG**: подієві атрибути + посилання на сесію, усі “типи/результати/методи” — **через довідники**.
* **x01**: передаємо **числовий оп‑код** (1/2/3), без текстів.
* **“Новий вхід”**: попередню сесію закриваємо `logout_date = login_date` + `close_reason_id = FORCED_NEW_LOGIN`.
* **Звіти**: через в’юшки з джойном довідників, у зберіганні — мінімум.

Хочеш — піджену міграційний скрипт (ALTER+UPDATE, щоб перенести старі текстові значення у довідники) під твої реальні назви схеми/таблиць.
