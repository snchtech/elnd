Для побудови схеми з прив’язками та атрибутами, найкращий підхід — розділити дані на декілька таблиць у базі даних, що відповідають вашим сутностям: альбоми, схеми, елементи та їхні прив’язки. 

Ось кроки, які потрібно виконати, та приклади реалізації:

---

### **1. Структура зберігання в базі даних**

#### Основні таблиці:

1. **`scheme_album`**: Зберігає інформацію про альбоми.
2. **`scheme`**: Зберігає схеми в рамках альбомів.
3. **`scheme_element`**: Зберігає графічні елементи схеми.
4. **`scheme_element_attributes`**: Динамічні атрибути елементів.
5. **`scheme_connections`**: Прив’язки між елементами (лінії, зв’язки тощо).

```sql
-- Таблиця альбомів
CREATE TABLE scheme_album (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(255) NOT NULL,
    depart_id NUMBER REFERENCES department(id),
    description CLOB,
    date_created DATE DEFAULT SYSDATE,
    date_updated DATE DEFAULT SYSDATE
);

-- Таблиця схем
CREATE TABLE scheme (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    album_id NUMBER REFERENCES scheme_album(id) ON DELETE CASCADE,
    name VARCHAR2(255) NOT NULL,
    format VARCHAR2(50),
    description CLOB,
    date_created DATE DEFAULT SYSDATE,
    date_updated DATE DEFAULT SYSDATE
);

-- Таблиця елементів схеми
CREATE TABLE scheme_element (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    scheme_id NUMBER REFERENCES scheme(id) ON DELETE CASCADE,
    type VARCHAR2(50) NOT NULL,
    x NUMBER,
    y NUMBER,
    width NUMBER,
    height NUMBER,
    rotation NUMBER DEFAULT 0,
    fill VARCHAR2(50),
    date_updated DATE DEFAULT SYSDATE
);

-- Таблиця атрибутів елементів
CREATE TABLE scheme_element_attributes (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    element_id NUMBER REFERENCES scheme_element(id) ON DELETE CASCADE,
    attribute_name VARCHAR2(255),
    attribute_value CLOB
);

-- Таблиця прив’язок елементів
CREATE TABLE scheme_connections (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    from_element_id NUMBER REFERENCES scheme_element(id) ON DELETE CASCADE,
    to_element_id NUMBER REFERENCES scheme_element(id) ON DELETE CASCADE,
    connection_type VARCHAR2(50)
);
```

---

### **2. API: Створення схеми**

#### **Маршрут `/api/createScheme`**

```javascript
import express from 'express';
import { pool } from './oraclePool'; // Підключення до Oracle через pool

const router = express.Router();

router.post('/api/createScheme', async (req, res) => {
  const { albumId, schemeName, format, description, elements, connections } = req.body;

  const connection = await pool.getConnection();

  try {
    // 1. Створення схеми
    const result = await connection.execute(
      `INSERT INTO scheme (album_id, name, format, description, date_created, date_updated) 
       VALUES (:albumId, :name, :format, :description, SYSDATE, SYSDATE) RETURNING id INTO :schemeId`,
      { albumId, name: schemeName, format, description, schemeId: { dir: oracledb.BIND_OUT, type: oracledb.NUMBER } }
    );

    const schemeId = result.outBinds.schemeId[0];

    // 2. Додавання елементів
    for (const element of elements) {
      const { id, type, x, y, width, height, rotation, fill, attributes } = element;

      const elementResult = await connection.execute(
        `INSERT INTO scheme_element (scheme_id, type, x, y, width, height, rotation, fill, date_updated) 
         VALUES (:schemeId, :type, :x, :y, :width, :height, :rotation, :fill, SYSDATE) RETURNING id INTO :elementId`,
        { schemeId, type, x, y, width, height, rotation, fill, elementId: { dir: oracledb.BIND_OUT, type: oracledb.NUMBER } }
      );

      const elementId = elementResult.outBinds.elementId[0];

      // 3. Додавання атрибутів елемента
      for (const attrName in attributes) {
        await connection.execute(
          `INSERT INTO scheme_element_attributes (element_id, attribute_name, attribute_value)
           VALUES (:elementId, :attrName, :attrValue)`,
          { elementId, attrName, attrValue: attributes[attrName] }
        );
      }
    }

    // 4. Додавання прив’язок
    for (const connectionData of connections) {
      const { fromElementId, toElementId, connectionType } = connectionData;

      await connection.execute(
        `INSERT INTO scheme_connections (from_element_id, to_element_id, connection_type)
         VALUES (:fromElementId, :toElementId, :connectionType)`,
        { fromElementId, toElementId, connectionType }
      );
    }

    await connection.commit();
    res.json({ success: true, schemeId });
  } catch (error) {
    console.error(error);
    await connection.rollback();
    res.status(500).json({ success: false, error: 'Error creating scheme.' });
  } finally {
    await connection.close();
  }
});

export default router;
```

---

### **3. API: Завантаження схеми**

#### **Маршрут `/api/getScheme/:schemeId`**

```javascript
router.get('/api/getScheme/:schemeId', async (req, res) => {
  const { schemeId } = req.params;
  const connection = await pool.getConnection();

  try {
    // 1. Завантаження схеми
    const schemeResult = await connection.execute(
      `SELECT * FROM scheme WHERE id = :schemeId`,
      { schemeId }
    );

    if (schemeResult.rows.length === 0) {
      return res.status(404).json({ success: false, message: 'Scheme not found.' });
    }

    const scheme = schemeResult.rows[0];

    // 2. Завантаження елементів
    const elementsResult = await connection.execute(
      `SELECT * FROM scheme_element WHERE scheme_id = :schemeId`,
      { schemeId }
    );

    const elements = elementsResult.rows.map((el) => ({
      id: el.ID,
      type: el.TYPE,
      x: el.X,
      y: el.Y,
      width: el.WIDTH,
      height: el.HEIGHT,
      rotation: el.ROTATION,
      fill: el.FILL,
    }));

    // 3. Завантаження атрибутів елементів
    for (const element of elements) {
      const attributesResult = await connection.execute(
        `SELECT attribute_name, attribute_value FROM scheme_element_attributes WHERE element_id = :elementId`,
        { elementId: element.id }
      );

      element.attributes = {};
      attributesResult.rows.forEach((attr) => {
        element.attributes[attr.ATTRIBUTE_NAME] = attr.ATTRIBUTE_VALUE;
      });
    }

    // 4. Завантаження прив’язок
    const connectionsResult = await connection.execute(
      `SELECT * FROM scheme_connections WHERE from_element_id IN (:elementIds) OR to_element_id IN (:elementIds)`,
      { elementIds: elements.map((el) => el.id) }
    );

    const connections = connectionsResult.rows.map((conn) => ({
      fromElementId: conn.FROM_ELEMENT_ID,
      toElementId: conn.TO_ELEMENT_ID,
      connectionType: conn.CONNECTION_TYPE,
    }));

    res.json({ success: true, scheme, elements, connections });
  } catch (error) {
    console.error(error);
    res.status(500).json({ success: false, error: 'Error fetching scheme.' });
  } finally {
    await connection.close();
  }
});
```

---

### **4. Завантаження та рендеринг у Next.js**

#### **Завантаження в Konva**

```javascript
useEffect(() => {
  const fetchScheme = async () => {
    const response = await fetch(`/api/getScheme/${schemeId}`);
    const data = await response.json();

    if (data.success) {
      setElements(data.elements);
    }
  };

  fetchScheme();
}, [schemeId]);
```

---

Цей підхід забезпечує:
1. **Чітку структуровану базу даних**.
2. **Легкість оновлення/видалення даних**.
3. **Гнучкість збереження складних структур елементів і прив’язок**.