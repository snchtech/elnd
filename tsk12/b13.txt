Ось як реалізувати функціонал **періодичного планування завдань**, включаючи зберігання, відображення та формування текстового опису (preview):

---

## ✅ 1. Види планування

### 🟦 Варіант 1: **Планування по днях тижня (щотижня)**

* **Назва режиму**: `WEEKLY_TIME_SCHEDULE`
* **UI**:

  * Checkbox List: `PERIOD_WEEKDAYS` (наприклад, значення `2,4,6`)
  * Time Picker (HTML `input type="time"`): `PERIOD_TIME` (наприклад, `09:00`)

### 🟦 Варіант 2: **Періодичність по N днях**

* **Назва режиму**: `INTERVAL_DAYS_MULTITIME`
* **UI**:

  * Number Item: `PERIOD_INTERVAL` (наприклад, `4`)
  * Multi-Select LOV: `HOURLY_TIMES` (значення типу: `06:00,09:00`)

---

## ✅ 2. Зберігання в БД

**TASK\_TEMPLATES**:

* `PERIOD_MODE` — режим (`WEEKLY_TIME_SCHEDULE`, `INTERVAL_DAYS_MULTITIME`)
* `PERIOD_WEEKDAYS` — CSV: `2,4,6`
* `PERIOD_TIME` — `09:00`
* `PERIOD_INTERVAL` — `4`
* `HOURLY_TIMES` — `06:00,09:00`
* `DATE_END` — дата завершення

---

## ✅ 3. Формування тексту-пояснення (Preview)

```plsql
-- PL/SQL функція (можна реалізувати як APEX item source або у view)
-- Або JS-функція на фронті:
function formatPreview(periodMode, weekdays, time, interval, hours) {
  if (periodMode === 'WEEKLY_TIME_SCHEDULE') {
    const daysMap = {
      '1': 'щонеділі', '2': 'щопонеділка', '3': 'щовівторка',
      '4': 'щосереди', '5': 'щочетверга', '6': 'щоп’ятниці', '7': 'щосуботи'
    };
    const dayLabels = weekdays.split(',').map(d => daysMap[d.trim()]);
    return `${dayLabels.join(', ')} о ${time}`;
  } else if (periodMode === 'INTERVAL_DAYS_MULTITIME') {
    return `Кожні ${interval} дні о ${hours}`;
  }
  return '';
}
```

🔹 **Приклад 1:**

> `WEEKLY_TIME_SCHEDULE` + `2,4,6` + `09:00`
> → `щопонеділка, щосереди, щоп’ятниці о 09:00`

🔹 **Приклад 2:**

> `INTERVAL_DAYS_MULTITIME` + `4` + `06:00,09:00`
> → `Кожні 4 дні о 06:00,09:00`

---

## ✅ 4. Таблиця для зберігання запланованих запусків

```sql
CREATE TABLE TASK_TEMPLATE_EXECUTIONS (
  ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  TEMPLATE_ID NUMBER NOT NULL,
  PLANNED_DATE DATE NOT NULL,
  STATUS VARCHAR2(20) DEFAULT 'PLANNED'
);
```

---

## ✅ 5. Генерація записів у таблицю запусків

```plsql
DECLARE
  v_next_date DATE := SYSDATE;
  v_end_date  DATE := :P_END_DATE;
BEGIN
  IF :P_PERIOD_MODE = 'INTERVAL_DAYS_MULTITIME' THEN
    FOR i IN 1 .. 50 LOOP
      EXIT WHEN v_next_date > v_end_date;
      FOR hour IN (SELECT REGEXP_SUBSTR(:P_HOURLY_TIMES, '[^,]+', 1, LEVEL) AS h
                   FROM dual
                   CONNECT BY LEVEL <= REGEXP_COUNT(:P_HOURLY_TIMES, ',') + 1)
      LOOP
        INSERT INTO TASK_TEMPLATE_EXECUTIONS (TEMPLATE_ID, PLANNED_DATE)
        VALUES (:P_TEMPLATE_ID, TO_DATE(TO_CHAR(v_next_date, 'YYYY-MM-DD') || ' ' || hour.h, 'YYYY-MM-DD HH24:MI'));
      END LOOP;
      v_next_date := v_next_date + TO_NUMBER(:P_PERIOD_INTERVAL);
    END LOOP;
  END IF;
  COMMIT;
END;
```

---

🔄 Якщо хочеш — можу також допомогти створити **процедуру генерації `DBMS_SCHEDULER JOB`** для Oracle.

Хочеш додати логіку генерації завдань по JOB?
