Зрозуміло! Якщо `taskid` — це окрема колонка, яка вказує на головне завдання (наприклад, це може бути ідентифікатор основного завдання, а не первинний ключ запису), тоді необхідно скоригувати запит. Вам потрібно знайти всі батьківські та дочірні елементи, де всі вони мають певний `taskid`, і створити ієрархічну нумерацію.

Ось як можна зробити запит, щоб отримати правильну ієрархію з нумерацією, де ви вказуєте `taskid` як головне завдання:

### Оновлений запит для ієрархії з `taskid`:

```sql
SELECT 
    SYS_CONNECT_BY_PATH(id, '.') AS hierarchy_number,  -- Створення ієрархічної нумерації
    t.* 
FROM 
    your_table t
WHERE 
    t.taskid = :taskid  -- Замість :taskid підставте конкретний taskid
START WITH 
    t.parentid IS NULL  -- Початкові елементи без батьків (кореневі)
CONNECT BY 
    PRIOR t.id = t.parentid  -- Зв'язок батьків і дітей
ORDER SIBLINGS BY t.id;  -- Сортування дочірніх елементів по ID
```

### Пояснення:

1. **`WHERE t.taskid = :taskid`** — фільтруємо дані за колонкою `taskid`, щоб працювати тільки з елементами, що належать до конкретного завдання.

2. **`START WITH t.parentid IS NULL`** — починаємо з кореневих елементів (де `parentid IS NULL`), це елементи, які не мають батьків.

3. **`CONNECT BY PRIOR t.id = t.parentid`** — рекурсивно шукаємо дочірні елементи. `PRIOR` позначає, що для кожного запису перевіряється, чи є він дочірнім для попереднього елемента (тобто, порівнюється поточний `parentid` з попереднім `id`).

4. **`SYS_CONNECT_BY_PATH(id, '.')`** — створюємо ієрархічну нумерацію. Функція `SYS_CONNECT_BY_PATH` формує шлях від кореня до кожного елемента, розділений крапкою. Це дозволяє створити нумерацію типу "1", "1.1", "1.1.1" тощо.

5. **`ORDER SIBLINGS BY t.id`** — сортуємо дочірні елементи по `id`, щоб вони йшли в правильному порядку.

### Приклад:

Якщо в таблиці є такі дані:

| id  | taskid | parentid | name    |
| --- | ------ | -------- | ------- |
| 1   | 100    | NULL     | Task 1  |
| 2   | 100    | 1        | Task 2  |
| 3   | 100    | 1        | Task 3  |
| 4   | 100    | 2        | Task 4  |
| 5   | 100    | 2        | Task 5  |
| 6   | 100    | 3        | Task 6  |

І ви вибираєте `taskid = 100`, результат буде виглядати так:

| hierarchy_number | id  | taskid | parentid | name   |
| ---------------- | --- | ------ | -------- | ------ |
| 1                | 1   | 100    | NULL     | Task 1 |
| 1.1              | 2   | 100    | 1        | Task 2 |
| 1.1.1            | 4   | 100    | 2        | Task 4 |
| 1.1.2            | 5   | 100    | 2        | Task 5 |
| 1.2              | 3   | 100    | 1        | Task 3 |
| 1.2.1            | 6   | 100    | 3        | Task 6 |

Тут:

- **`1`, `1.1`, `1.1.1`** — це ієрархічна нумерація для кожного завдання в межах одного головного `taskid`.
- **`ORDER SIBLINGS BY t.id`** — забезпечує сортування дочірніх елементів по `id`.

### Підсумок:
Цей запит допомагає відсортувати завдання за `taskid` і побудувати ієрархічну нумерацію для кожного елемента, де кореневі елементи позначаються як "1", їхні дочірні елементи — як "1.1", "1.1.1" тощо.